<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: cpp-course-intermediate - Victor&#039;s Personal Page</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Victor&#039;s Personal Page"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Victor&#039;s Personal Page"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Victor&#039;s Personal Page"><meta property="og:url" content="https://victorserranomoroder.github.io/"><meta property="og:site_name" content="Victor&#039;s Personal Page"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://victorserranomoroder.github.io/img/og_image.png"><meta property="article:author" content="Víctor Serrano Moroder"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://victorserranomoroder.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://victorserranomoroder.github.io"},"headline":"Victor's Personal Page","image":["https://victorserranomoroder.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Víctor Serrano Moroder"},"publisher":{"@type":"Organization","name":"Victor's Personal Page","logo":{"@type":"ImageObject","url":"https://victorserranomoroder.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Victor's Personal Page" type="application/atom+xml">
</head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/" alt="Victor&#039;s Personal Page" height="28"><img class="logo-img-dark" src="/" alt="Victor&#039;s Personal Page" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/curriculum">Curriculum</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/categories/article">Articles</a><a class="navbar-item" href="/cpp-course">C++ Course</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">cpp-course-intermediate</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-11-10T00:00:00.000Z" title="11/10/2025, 12:00:00 AM">10-11-2025</time></span><span class="level-item"><a class="link-muted" href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></span><span class="level-item">9 minutes read (About 1322 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/">C++Medium - Type Conversion and Object Casting</a></p><div class="content"><p>Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or interfacing with APIs, type conversions determine how data is interpreted and how objects behave.</p>
<h1 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h1><p>Type conversion occurs whenever a value of one type is transformed into another type. C++ supports two broad categories.</p>
<h2 id="Implicit-Conversions"><a href="#Implicit-Conversions" class="headerlink" title="Implicit Conversions"></a>Implicit Conversions</h2><p>These occur without writing a cast:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a &#123;<span class="number">42.42</span>&#125;;</span><br><span class="line"><span class="type">int</span> b&#123;a&#125;; <span class="comment">// a is implicitly converted to double but values can be truncated due to narrowing conversion: b = 42</span></span><br></pre></td></tr></table></figure>
<p>As you can tell, in the previous example <code>b</code> losses the decimal data from <code>a</code>, <strong>safe convertion does not avoid data loss</strong>. Implicit conversions aim to be safe, but narrowing conversions (like <code>double</code> → <code>int</code>) may still happen and can silently lose data.</p>
<h2 id="Explicit-Conversions"><a href="#Explicit-Conversions" class="headerlink" title="Explicit Conversions"></a>Explicit Conversions</h2><p>As it names suggest explicit type conversions need the programmer to manually change data from one type to another. This is also known as <strong>Type Casting</strong>.</p>
<p>There are 3 major ways in which we can use explicit conversion in C++:</p>
<ul>
<li><strong>C Notation</strong></li>
<li><strong>Function Notation</strong></li>
<li><strong>C++ Casts</strong></li>
</ul>
<p>As you will see the older C and C++ notations are discouraged because these notations hide the intent of the conversion and can silently perform dangerous reinterpretations. <strong>Prefer C++ casts because they make your intent explicit</strong>.</p>
<h3 id="C-Notation-discouraged"><a href="#C-Notation-discouraged" class="headerlink" title="C Notation (discouraged)"></a>C Notation (discouraged)</h3><p>As the name suggests, this type of casting is favored in C . It is also known as <strong>cast notation</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// (data_type)expression</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">double</span> my_double&#123;&#125;; <span class="comment">// Remember to not rely on default initialization!</span></span><br><span class="line">my_double = (<span class="type">double</span>)my_int;</span><br></pre></td></tr></table></figure>

<h3 id="Function-Notation-discouraged"><a href="#Function-Notation-discouraged" class="headerlink" title="Function Notation (discouraged)"></a>Function Notation (discouraged)</h3><p>We can also use the function-like notation to cast data from one type to another.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// data_type(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">double</span> my_double&#123;&#125;;</span><br><span class="line"></span><br><span class="line">my_double = <span class="built_in">double</span>(my_int);</span><br></pre></td></tr></table></figure>

<h3 id="C-Casts"><a href="#C-Casts" class="headerlink" title="C++ Casts"></a>C++ Casts</h3><p>The most idiomatic way of dealing with type casting is by using <strong>C++ Casts</strong>, C++ offers four expressions for explicit type conversion:</p>
<ul>
<li><strong>static_cast</strong></li>
<li><strong>dynamic_cast</strong></li>
<li><strong>const_cast</strong></li>
<li><strong>reinterpret_cast</strong></li>
</ul>
<p>The key of using C++ casts is to know when and how to use each one. Let’s explore each cast, understand its purpose, and discuss when it should or should not be used.</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>It is the most common and most versatile C++ cast. <code>static-cast</code> uses a combination of implicit of implicit and user-defined conversions to work properly. In practice this means that <strong>this cast is compile-time checked and mostly safe</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// static_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> my_double &#123;<span class="number">42.42</span>&#125;;</span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(my_double)&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use"><a href="#When-To-Use" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>For well-defined and <strong>compile checked</strong> conversions.</li>
<li>Numeric conversions.</li>
<li><strong>Upcasting</strong> in inheritance.</li>
<li>Calling <code>explicit</code> constructors.</li>
</ul>
<h5 id="When-not-to-use"><a href="#When-not-to-use" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>When <strong>downcasting</strong> polymorphic classes -&gt; use <code>dynamic_cast</code> instead.</li>
<li>When the conversion may be unsafe or ambiguous.</li>
</ul>
<hr>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>This cast should <strong>exclusively be used on polymorphic types</strong> (AKA, <em>classes with at least one virtual method</em>). The most common use case for <code>dynamic_cast</code> is on <strong>Downcasting</strong>. In practice this means that <strong>this cast performs a runtime safety check</strong> and prevents unsafe conversions by returning <code>nullptr</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// dynamic_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line"><span class="comment">// Perform Downcast from Base to Derived</span></span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (derived)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Conversion succesful</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Conversion failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-1"><a href="#When-To-Use-1" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>When you need to <strong>downcast</strong>.</li>
<li>When dealing with class hierarchies and dynamic polymorphism.</li>
</ul>
<h5 id="When-not-to-use-1"><a href="#When-not-to-use-1" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>When dealing with non-polymorphic types.</li>
<li>When performance is critical. <code>dynamic_cast</code> can be expensive due to vtable lookups.</li>
</ul>
<hr>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>This cast expression adds or removes <code>const</code> or <code>volatile</code> qualifiers. Usage of this cast expression is reduced only to compatibility with legacy APIs and a few corner cases. The reason is that removing <code>const</code> from a truly constant object and then modifying it is <strong>undefined behavior</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// const_cast&lt;type_w/o_const&gt;(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value &#123;<span class="number">42</span>&#125;;            <span class="comment">// a const int</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;value));   <span class="comment">// dangerous: UB if foo modifies it</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>; <span class="comment">// a non-const int</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* value = &amp;x;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;value)); <span class="comment">// safe: x was not originally const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-2"><a href="#When-To-Use-2" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>When passing const pointers to legacy APIs</li>
<li>Removing <code>const</code> from objects that originally were non-const</li>
</ul>
<h5 id="When-not-to-use-2"><a href="#When-not-to-use-2" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>Anytime modifying a truly <code>const</code> object.</li>
<li>In any other case the use of this cast is strongly discouraged.</li>
</ul>
<hr>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p><strong>This is most likely the most dangerous type of cast</strong>. It reinterprets the raw bits of a value or pointer as another <em>completely</em> unrelated type. Because it can easily break aliasing rules, type safety, and memory assumptions, use it only when you fully understand the implications.</p>
<p>It is good practice to be skeptical and cautious when encountering this casting expression on a code base and it should also be accompanied by a comment block justifying the use of this cast and why it is necessary.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// reinterpret_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line">std::<span class="type">uint32_t</span> raw = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="comment">// Comment explaining why reinterpret_cast is necessary</span></span><br><span class="line"><span class="type">char</span>* bytes = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;raw);</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-3"><a href="#When-To-Use-3" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>In low-level programming.</li>
<li>When dealing with hardware or network packets.</li>
</ul>
<h5 id="When-not-to-use-3"><a href="#When-not-to-use-3" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>Everywhere else.</li>
</ul>
<h3 id="TL-DR-Use-the-right-cast"><a href="#TL-DR-Use-the-right-cast" class="headerlink" title="TL;DR Use the right cast"></a>TL;DR Use the right cast</h3><ul>
<li>Prefer <code>static_cast</code> for normal, well-defined conversions.</li>
<li>Use <code>dynamic_cast</code> only when downcasting polymorphic objects and you need runtime safety.</li>
<li>Use <code>const_cast</code> only to interface with legacy APIs, never modify a truly const object.</li>
<li>Use <code>reinterpret_cast</code> <strong>only when absolutely necessary</strong> in low-level code, it is dangerous.</li>
<li><strong>Avoid C-style and function-style casts</strong> because they hide intent and may perform unsafe conversions.</li>
</ul>
<h1 id="Object-Casting-in-C"><a href="#Object-Casting-in-C" class="headerlink" title="Object Casting in C++"></a>Object Casting in C++</h1><p>When dealing with inheritance, C++ allows you to <strong>convert pointers and references between base and derived types</strong>. These conversions called <strong>object casting</strong>, are central to polymorphism, but must be used carefully to avoid undefined behavior.</p>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a>Upcasting</h2><p>Upcasting is converting a <em>derived type to its base type</em>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DerivedA derived&#123;&#125;;</span><br><span class="line">Base* ptr = &amp;derived; <span class="comment">// Upcast — implicit and always safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quite useful to make heterogeneous containers</span></span><br><span class="line">std::list&lt;Base*&gt;list&#123;&#125;;</span><br><span class="line">list.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="keyword">new</span> DerivedB&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Upcasting works because a Derived object is a Base</strong> and <strong>it is always safe</strong>.</p>
<p>Calling virtual functions through Base* or Base&amp; dispatches to overridden Derived implementations.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line">    <span class="comment">// static_cast can be used but it can also be implicit</span></span><br><span class="line">    Base* ptr_b = <span class="built_in">static_cast</span>&lt;Base*&gt;(<span class="keyword">new</span> Derived&#123;&#125;);</span><br><span class="line">    ptr-&gt;<span class="built_in">foo</span>(); <span class="comment">// Prints Derived Foo</span></span><br><span class="line">    ptr_b-&gt;<span class="built_in">foo</span>(); <span class="comment">// Prints Derived Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Downcasting"><a href="#Downcasting" class="headerlink" title="Downcasting"></a>Downcasting</h2><p>Downcasting converts a base type to a derived type. <strong>Downcasting is not inherently safe</strong> because a Base* may not actually point to a Derived object. When done incorrectly, the behavior is undefined. <strong>For safe downcasting</strong>, C++ offers <code>dynamic_cast</code>, which relies on <strong>runtime type information (<code>RTTI</code>)</strong>.</p>
<p><code>RTTI</code> has its limitations:</p>
<ul>
<li>Works only with polymorphic types (at least one virtual function).</li>
<li>On pointer types:<ul>
<li><em>success</em> -&gt; valid pointer</li>
<li><em>failure</em> -&gt; <code>nullptr</code></li>
</ul>
</li>
<li>On reference types:<ul>
<li><em>failure</em> -&gt; throws <code>std::bad_cast</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* d_scast = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// Downcast, unsafe unless you KNOW the dynamic type</span></span><br><span class="line">Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="comment">// Safe downcast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Success: b actually pointed to a Derived</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Failed: b was not a Derived</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-Slicing"><a href="#Object-Slicing" class="headerlink" title="Object Slicing"></a>Object Slicing</h2><p>Object slicing occurs when a derived object is <strong>assigned or passed by value</strong> into a base-type variable:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base b = d;   <span class="comment">// Slices off Derived-specific parts</span></span><br></pre></td></tr></table></figure>

<p><strong>The Base object receives only its own fields</strong>; all Derived state is lost.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line">    <span class="comment">// Object is sliced and Derived specific info is lost</span></span><br><span class="line">    Base value = *ptr;</span><br><span class="line">    value.<span class="built_in">foo</span>(); <span class="comment">// Prints Base Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To avoid slicing:</p>
<ul>
<li>Pass by reference or pointer</li>
<li>Use smart pointers (<code>std::unique_ptr</code>, etc.)</li>
<li>Design classes for polymorphic use (virtual destructors, etc.)</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-11-10T00:00:00.000Z" title="11/10/2025, 12:00:00 AM">10-11-2025</time></span><span class="level-item"><a class="link-muted" href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></span><span class="level-item">7 minutes read (About 1030 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/cpp-course-intermediate/2-2-Ownership-And-Resource-Management/">C++Medium - Ownership and Resource Management</a></p><div class="content"><p>In the Basics Course we explored how to manage memory resources by using tools like pointers to allocate, access and modify the memory located in the Heap. Memory located in the heap require manual control of data lifetime thus, requiring careful management to avoid memory leaks or illegal memory accesses.</p>
<p>Here is a quick recap on what operators are used on heap memory management:</p>
<p>In C we have the following operators:</p>
<ul>
<li><code>malloc(size)</code> is used to dynamically allocate a block of memory on the heap.</li>
<li><code>memcpy(dest, source, size)</code> is used to copy a block of memory from one location to another.</li>
<li><code>free(ptr)</code> is used to release memory previously allocated on the heap.</li>
</ul>
<p>In C++ we have modern alternatives that usually work better than their C counterparts</p>
<ul>
<li><code>new</code> is used to dynamically allocate a block of memory on the heap.</li>
<li><code>delete</code> is used to release memory previously allocated on the heap.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* valA_ = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    MyClass* valB_ = <span class="keyword">new</span> MyClass&#123;&#125;;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    <span class="keyword">delete</span> valA_;</span><br><span class="line">    <span class="keyword">delete</span> valB_;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So far, by simply calling new and delete by themselves, we haven’t fully leveraged the advantages of object-oriented programming. OOP provides a powerful concept called <strong>ownership</strong>.</p>
<h1 id="Introducing-Ownership"><a href="#Introducing-Ownership" class="headerlink" title="Introducing Ownership"></a>Introducing Ownership</h1><p>In OOP mid-level languages like <em>C++</em> and <em>Rust</em>, <strong>ownership</strong> and resource management are central concepts that <strong>define who is responsible for an object’s lifetime</strong>, when memory or resources are released, and how to avoid memory leaks or undefined behavior. Proper management is critical, because there’s no garbage collector the programmer is responsible for cleaning up.</p>
<h2 id="Ownership-Models"><a href="#Ownership-Models" class="headerlink" title="Ownership Models"></a>Ownership Models</h2><p>Ownership refers to which part of the program is responsible for an object. The most known models are:</p>
<ol>
<li><strong>Exclusive Ownership</strong> <code>std::unique_ptr</code><ul>
<li>One owner is responsible for the lifetime of the object.</li>
<li>Safe: no accidental sharing or double deletes.</li>
</ul>
</li>
<li><strong>Shared Ownership</strong> <code>std::shared_ptr</code><ul>
<li>Multiple owners can hold references to the same object</li>
<li>Lifetime is tied to the number of owners; object is destroyed when the last owner is gone.</li>
</ul>
</li>
<li><strong>Weak Ownership</strong> <code>std::weak_ptr</code><ul>
<li>A pointer or reference to an object without taking ownership.</li>
<li>Must be careful: the reference must not outlive the object.</li>
</ul>
</li>
</ol>
<h1 id="Ownership-in-C-RAII"><a href="#Ownership-in-C-RAII" class="headerlink" title="Ownership in C++: RAII"></a>Ownership in C++: RAII</h1><p><strong>RAII (Resource Acquisition Is Initialization) is the idiomatic C++ approach to resource management</strong>. It’s one of the most powerful features that sets C++ apart from C, because it ties resource lifetime directly to object lifetime, eliminating many manual memory management errors.</p>
<p>To archieve RAII-like features and object must (roughly) display the following behaviors:</p>
<ul>
<li>Adquire a resource in a constructor.</li>
<li><strong>Release the resource in the destructor</strong>.</li>
<li><strong>Ensure that resources are always released</strong>, even in the presence of exceptions.</li>
</ul>
<p><strong>RAII</strong> is more than a coding pattern, it is a defining concept in C++. Until now, classes and structs have often served as mere semantic wrappers. <strong>Ownership and RAII give them deeper meaning by binding the lifetime of their members to the lifetime of their owner</strong>. This principle not only ensures safe and predictable behavior but also <strong>translates directly into UML</strong> diagrams, making relationships, ownership, and lifetimes explicit and easy to reason about.</p>
<p>Many standard C++ features leverage RAII. For example, <strong>STL containers manage their own memory</strong>, which is why you do not need to manually delete elements when using containers like <code>std::list</code> or <code>std::vector</code>.</p>
<p><em>RAII is fundamental to writing clear, maintainable, and safe C++ code understanding it is essential for any C++ developer.</em></p>
<h2 id="RAII-in-action"><a href="#RAII-in-action" class="headerlink" title="RAII in action"></a>RAII in action</h2><p>Let’s see an example on how RAII is implemented in a custom object.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Minimal example</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">const</span> std::list&lt;<span class="type">int</span>&gt;&amp; list)</span><br><span class="line">        : list_&#123;list&#125;</span><br><span class="line">        , my_data_&#123;<span class="keyword">new</span> <span class="type">float</span>&#123;&#125;&#125; <span class="comment">// Constructor acquires the resource</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">MyClass</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> my_data_; <span class="comment">// The destructor releases the resource</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// List is a reference, not owned by this instance</span></span><br><span class="line">        <span class="type">const</span> std::list&lt;<span class="type">int</span>&gt;&amp; list_;</span><br><span class="line">        <span class="comment">// my_data_ is a pointer initialized in the constructor, so the object is responsible of managing its lifetime</span></span><br><span class="line">        <span class="type">float</span>* my_data_; <span class="comment">// The object owns the resource (my_data_)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RAII can be fully achieved by giving objects the necessary behaviors to manage their own memory. However, C++ already provides tools and classes in the STL that implement RAII for us, one of the most used are <strong>smart pointers</strong>.</p>
<h1 id="Smart-Pointers"><a href="#Smart-Pointers" class="headerlink" title="Smart Pointers"></a>Smart Pointers</h1><p>Smart pointers allow you to manage resources automatically and make it explicit that the object follows RAII principles, often reducing boilerplate and potential errors. In C++, they come in three flavors, corresponding to different ownership models:</p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code> represents <strong>exclusive ownership</strong> of a resource. Only one <code>unique_ptr</code> can own the object at a time. When the unique_ptr goes out of scope, it automatically deletes the resource.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); <span class="comment">// Creates a unique_ptr managing an int</span></span><br><span class="line"><span class="comment">// No need to manually delete it; it will be released automatically</span></span><br></pre></td></tr></table></figure>

<p>Key points:</p>
<ul>
<li>It <strong>cannot be copied, only moved</strong>.</li>
<li>Most performant-wise type of smart pointer.</li>
<li>Ideal for single ownership.</li>
</ul>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code> represents <strong>shared ownership</strong>. Multiple <code>shared_ptr</code> instances can manage the same resource. The resource is only deleted when the <strong>last owner</strong> goes out of scope. Internally, shared_ptr maintains a reference counter: the counter increases when it is copied and decreases when one of its instances is destroyed. When the counter drops to zero, the resource is automatically deleted.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> ptr2 = ptr1; <span class="comment">// Both ptr1 and ptr2 share ownership</span></span><br><span class="line"><span class="comment">// Resource will be deleted automatically when both go out of scope</span></span><br></pre></td></tr></table></figure>

<p>Key points:</p>
<ul>
<li>Maintains a reference count internally.</li>
<li>Use when multiple parts of your app needs access to the same resource (Strong Association).</li>
<li>Heavier on performace that <code>unique_ptr</code> due to reference counting.</li>
</ul>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code> is a non-owning reference or <strong>weak ownership</strong> to a resource managed by a <code>shared_ptr</code>. It allows you to observe the resource without affecting its lifetime, which is useful to avoid cyclic references.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak = shared; <span class="comment">// weak_ptr does not increase reference count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> observed = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// Safe access to the resource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Key points:</p>
<ul>
<li>Does not manage or control resources lifetime</li>
<li>Can be converted to shared_ptr temporarily with lock() -&gt; borrows ownership temporarily</li>
<li>Common in observer patterns</li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Víctor Serrano Moroder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Víctor Serrano Moroder</p><p class="is-size-6 is-block">C++ Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Madrid, Spain</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/victorserranomoroder" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/victorserranomoroder"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/v%C3%ADctor-serrano-moroder/"><i class="fab fa-linkedin"></i></a></div></div></div><!--!--><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=g6xrmgy1n1m&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="g6xrmgy1n1m" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/article/"><span class="level-start"><span class="level-item">article</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/cpp-course-basic/"><span class="level-start"><span class="level-item">cpp-course-basic</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/cpp-course-intermediate/"><span class="level-start"><span class="level-item">cpp-course-intermediate</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-11-10T00:00:00.000Z">10-11-2025</time></p><p class="title"><a href="/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/">C++Medium - Type Conversion and Object Casting</a></p><p class="categories"><a href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-11-10T00:00:00.000Z">10-11-2025</time></p><p class="title"><a href="/cpp-course-intermediate/2-2-Ownership-And-Resource-Management/">C++Medium - Ownership and Resource Management</a></p><p class="categories"><a href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-10T00:00:00.000Z">10-09-2025</time></p><p class="title"><a href="/cpp-course-basic/1-5-Basic-Project-Structure/">C++Basics 5. Basic Project Structure</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-18T00:00:00.000Z">18-08-2025</time></p><p class="title"><a href="/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/">C++Basics 4. Object-Oriented Programming in C++</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-17T00:00:00.000Z">17-08-2025</time></p><p class="title"><a href="/cpp-course-basic/1-3-Functions/">C++Basics 3. Functions</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/11/"><span class="level-start"><span class="level-item">November 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/09/"><span class="level-start"><span class="level-item">September 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">August 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/" alt="Victor&#039;s Personal Page" height="28"><img class="logo-img-dark" src="/" alt="Victor&#039;s Personal Page" height="28"></a><p class="is-size-7"><span>&copy; 2025 Víctor Serrano Moroder</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2025</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>