<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victor&#39;s Personal Page</title>
  
  
  <link href="https://victorserranomoroder.github.io/atom.xml" rel="self"/>
  
  <link href="https://victorserranomoroder.github.io/"/>
  <updated>2025-09-14T09:21:51.804Z</updated>
  <id>https://victorserranomoroder.github.io/</id>
  
  <author>
    <name>Víctor Serrano Moroder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++Basics 5. Basic Project Structure</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-5-Basic-Project-Structure/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-5-Basic-Project-Structure/</id>
    <published>2025-09-10T00:00:00.000Z</published>
    <updated>2025-09-14T09:21:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>If you’ve reached this far, congratulations! You can now write simple C++ applications and apply basic OOP concepts.</p><p>But real-world applications are organized quite differently from the small examples you’ve seen so far. C and C++ have a distinctive way of structuring code. In this post we’ll explore how to lay out a simple but scalable C++ project, covering headers, source files and some basic code organization.</p><span id="more"></span><h1 id="Headers-and-Source-Files"><a href="#Headers-and-Source-Files" class="headerlink" title="Headers and Source Files"></a>Headers and Source Files</h1><p>In small examples you’ve probably written everything inside a single <code>.cpp</code> file. This is fine for proofs of concept and small prototypes, but it quickly becomes unmanageable as your codebase grows.</p><p>C++ projects usually separate the <strong>interface</strong> (declarations) from the <strong>implementation</strong> (definitions).</p><h2 id="Header-files-hpp"><a href="#Header-files-hpp" class="headerlink" title="Header files (.hpp)"></a>Header files (<code>.hpp</code>)</h2><p>Header files act as an <strong>interface</strong>: they tell other parts of your program how to use your code without exposing how it works internally. They typically contain declarations of classes, functions, constants, and templates.</p><p>A key aspect of header files is that they are <strong>not compiled on their own</strong>. In fact, if both the declarations and definitions are stored entirely within a header (a “header-only” library), it can be used in any project simply by including the header, without linking against a compiled library. These self-contained libraries are praised for being easy to integrate, examples include <a href="https://github.com/nothings/stb">stb_image</a> and <a href="https://github.com/marzer/tomlplusplus">toml++</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">int</span> data);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">set_data</span><span class="params">(<span class="type">int</span> data)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Source-Files-cpp"><a href="#Source-Files-cpp" class="headerlink" title="Source Files (.cpp)"></a>Source Files (<code>.cpp</code>)</h2><p>Source files define how the declarations in the <code>.hpp</code> actually work. They implement function bodies and class methods. The corresponding header is included at the top so the compiler knows the declarations you’re defining. <strong>Source files are compiled</strong> and then linked together to form an executable or library.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> data)</span><br><span class="line">: data_&#123;data&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::set_data</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data_ = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyClass::get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Project-Organization"><a href="#Project-Organization" class="headerlink" title="Project Organization"></a>Project Organization</h1><p>Project folder structure and code organization can vary widely depending on project requirements and team preferences. So I’ll keep this section short. This can also depend on whether or not the project is going to be used as a library or a fully fledged application.</p><p>A small C++ library usually keeps <code>.hpp</code> and <code>.cpp</code> split, this is because if any program tries to use your library it will need clear access to its public <code>interface</code> and remember that <code>.hpp</code> files pretty much fulfills the public interface role.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/build  # Generated build artifacts (object files, binaries)</span><br><span class="line">CMakeLists.txt # Project build definition file</span><br><span class="line">/docs # Project docs (README, API docs)</span><br><span class="line">/include # Public header files (.hpp)</span><br><span class="line">/src # Source files (.cpp) and private headers</span><br><span class="line">/tests # Test files for unit testing</span><br></pre></td></tr></table></figure><p>A small C++ application usually groups both <code>.hpp</code> and <code>.cpp</code> together as there is no need to share its functionality with anyone:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/build  # Generated build artifacts (object files, binaries)</span><br><span class="line">CMakelist.txt # Project build definition file</span><br><span class="line">/docs # Project docs (README, API docs)</span><br><span class="line">/include # Public header files (.hpp)</span><br><span class="line">/src # Source files (.cpp) and headers (.hpp)</span><br><span class="line">/tests # Test files for unit testing</span><br></pre></td></tr></table></figure><h2 id="Code-Organization-with-Namespaces"><a href="#Code-Organization-with-Namespaces" class="headerlink" title="Code Organization with Namespaces"></a>Code Organization with Namespaces</h2><p>Again, code organization relies quite heavily on the project type and requirements, so its not worth it to delve deep into this, but I think there is a feature that it is worth mentioning called <code>Namespaces</code>.</p><p>A namespace is a declarative region that provides a unique scope for identifiers like classes, functions, variables… This is quite useful to <strong>prevent name conflicts</strong>. Let’s see a quick example and also learn why <code>using namespace</code> can be dangerous:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">TClass</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// list members...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// So... what list are we trying to initialize?</span></span><br><span class="line">    <span class="comment">// This won&#x27;t compile due to name collision</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; my_list&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now you can clearly see why <code>using namespace</code> is discouraged in most cases. Let’s see a counterexample on how to deal with this situation:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">TClass</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// list members...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; my_list&#123;&#125;;   <span class="comment">// Standard library list</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; my_other_list&#123;&#125;;  <span class="comment">// custom list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This can be also be seen in the same project:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/Tensor.hpp</span></span><br><span class="line"><span class="keyword">namespace</span> app::core</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tensor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/models/Tensor.hpp</span></span><br><span class="line"><span class="keyword">namespace</span> app::models</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Tensor</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/MainApplication.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;core/Tensor.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;models/Tensor.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> app</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MainApplication</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">        core::Tensor cTensor_;</span><br><span class="line">        models::Tensor mTensor_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Don’t get me wrong, <code>using namespace</code> can be useful and does indeed improve readability when it is pretty much clear what are we trying to use. Let’s see a use case example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants.hpp</span></span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_a&#123;yabba::daba::doo::quite::a::mouthfull::MyEnum::First&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_b&#123;yabba::daba::doo::quite::a::mouthfull::MyEnum::Second&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_c&#123;yabba::daba::doo::quite::a::mouthfull::MyEnum::Third&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_d&#123;yabba::daba::doo::quite::a::mouthfull::MyEnum::Forth&#125;;</span><br></pre></td></tr></table></figure><p>As you can see, dealing with nested namespaces can be quite verbose, this verbosity can be necessary but it is indeed a double edged sword. As it is certain that we know what types we are dealing with, this is a perfect situation to use <code>using namespace</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants.hpp</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> yabba::daba::doo::quite;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;mouthfull::MyEnum&gt; constant_a&#123;mouthfull::MyEnum::First&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;mouthfull::MyEnum&gt; constant_b&#123;mouthfull::MyEnum::Second&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;mouthfull::MyEnum&gt; constant_c&#123;mouthfull::MyEnum::Third&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::initializer_list&lt;mouthfull::MyEnum&gt; constant_d&#123;mouthfull::MyEnum::Fourth&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;If you’ve reached this far, congratulations! You can now write simple C++ applications and apply basic OOP concepts.&lt;/p&gt;
&lt;p&gt;But real-world applications are organized quite differently from the small examples you’ve seen so far. C and C++ have a distinctive way of structuring code. In this post we’ll explore how to lay out a simple but scalable C++ project, covering headers, source files and some basic code organization.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 4. Object-Oriented Programming in C++</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/</id>
    <published>2025-08-18T00:00:00.000Z</published>
    <updated>2025-09-14T08:47:06.149Z</updated>
    
    <content type="html"><![CDATA[<p>Well, I think we’ve found where the ++ in C++ was.<br>I could agree with this statement, at least in its origins, C++ has evolved to be a superset of C that quite revamps it introducing modern concepts. But first things first.</p><span id="more"></span><h1 id="The-building-blocks-of-OOP-Objects-and-Responsibility"><a href="#The-building-blocks-of-OOP-Objects-and-Responsibility" class="headerlink" title="The building blocks of OOP, Objects and Responsibility"></a>The building blocks of OOP, Objects and Responsibility</h1><p>C++ is by design an <strong>Object-Oriented Programming (OOP)</strong> language. OOP is a way of writing programs that organizes data and behavior into <strong>objects</strong>. An object groups together information (called attributes or <strong>member variables</strong>) and the actions that can be performed on it (called methods or <strong>member functions</strong>). This approach makes programs easier to structure, reuse, and maintain.</p><p>A key principle in OOP design is <strong>encapsulation</strong>, which means that an object should hide its internal details and only expose what is necessary. <strong>Encapsulation</strong> helps reduce <strong>coupling</strong>, making objects more independent and easier to maintain.</p><p>This prevents objects from reaching deeply into other objects’ internals, further reducing coupling and keeping the design clean.</p><p>In C++, <strong>visibility specifiers</strong> are the main tool for enforcing <strong>encapsulation</strong>:</p><ul><li><code>public</code>: members specified as <strong>public</strong> can be accessed from other objects freely.</li><li><code>protected</code>: members specified as <strong>protected</strong> can be accessed from <strong>derived</strong> objects.</li><li><code>private</code>: members specified as <strong>private</strong> cannot be accessed from other objects.</li></ul><p>After a brief dive into the dephts of applied design principles in C++, let’s see how C++ allows us to implement objects, let’s start with an previously visited concept.</p><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>We’ve already explored the minimal expression of these <strong>objects</strong> when we talked about <strong>structs</strong>.<br>These can behave as:</p><ul><li><strong>Plain Old Data (POD)</strong> objects, in a nutshell, <strong>aggregates</strong> of data that share a semantic relationship.</li><li><strong>Objects</strong> structures that define not only semantically related data but also behavior in the form of <strong>member functions</strong>.</li></ul><p>Struct members have <strong>public</strong> visibility access by default.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAggregate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Both a,b are publicly accessible</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>Classes are pretty much identical to structs, but feature <strong>private</strong> default access to members. This is mainly the reason why <strong>in practice, classes are preferred over structs</strong> as they are seen as better suited for <strong>encapsulation</strong>.</p><p>Lets see an example that showcases how classes work:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data)</span><br><span class="line">    : data_&#123;data&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">foo</span>(); <span class="comment">// foo can be called as it is in the same class</span></span><br><span class="line">        <span class="keyword">return</span> data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize object</span></span><br><span class="line">    MyClass my_obj&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call to public function</span></span><br><span class="line">    <span class="type">int</span> result = my_obj.<span class="built_in">get_data</span>(); <span class="comment">// Returns 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In these example we’ve “smoothly” introduced a concept that deserves its own section.</p><h3 id="Object-Constructors"><a href="#Object-Constructors" class="headerlink" title="Object Constructors"></a>Object Constructors</h3><p><strong>Constructors</strong> are functions that define how an object has to be initialized. Although we are introducing this concept with classes they can be found in <strong>structs</strong> aswell.</p><p>A constructor job is to initialize its members. In C++ constructors is good practice to initialize members by <strong>List initialization</strong> instead of relying on <strong>Default Initialization</strong>. (We’ll delve more deeply into initialization types in the following course).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyClass</span>(<span class="type">int</span> data)</span><br><span class="line">        : data_&#123;data&#125; <span class="comment">//List initialized member</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Other has been default-initialized and then</span></span><br><span class="line">            <span class="comment">// we have assigned its value. Not optimal.</span></span><br><span class="line">            other_ = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data_;</span><br><span class="line">        <span class="type">int</span> other_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-Destructors"><a href="#Object-Destructors" class="headerlink" title="Object Destructors"></a>Object Destructors</h3><p>Having explained constructors, its easier to understand <strong>destructors</strong>. Destructors are functions triggered when and object is deleted, depending on where the object is allocated in memory its destruction will be triggered by different reasons:</p><ul><li><code>stack</code>: stack allocated objects are deleted when leaving its scope or when its <strong>owner</strong> deletes it.</li><li><code>heap</code>: heap allocated objects are deleted explicitly by  a <code>delete</code> call.</li></ul><p>An important concept is <strong>destruction order</strong>, when an object is notified to be destroyed it must also notify the destruction of its members, and it does it in a very specific order. In C++ member destruction is triggered in an <strong>inverse initialization order</strong> or from the <strong>bottom to the top</strong>. This is <strong>important</strong> as in some cases it could derive in <strong>lifetime issues</strong> and it could hinder propper app exit among other subtle possible issues. After all members have been destroyed the object deletes itself. This is also a quick look at how <strong>RAII (Resource Adquisition Is Initialization)</strong> idiom (pattern) that we will explore in the following course together with the previously mentioned concepts. Let’s get back on track.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor initializes both members</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) <span class="comment">// Latest to destroy</span></span><br><span class="line">    : stack_data_&#123;data&#125;</span><br><span class="line">    , heap_data_&#123;<span class="keyword">new</span> <span class="type">int</span>&#123;data&#125;&#125;</span><br><span class="line">    , object_a_&#123;&#125; <span class="comment">// Latest to initialize, first to destroy</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class destructor</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Heap allocated memory has to be explicitly deleted</span></span><br><span class="line">        <span class="keyword">delete</span> heap_data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> stack_data_;</span><br><span class="line">    <span class="type">int</span>* heap_data_;</span><br><span class="line">    ObjectA object_a_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Inheritance-in-C"><a href="#Inheritance-in-C" class="headerlink" title="Inheritance in C++"></a>Inheritance in C++</h2><p>Inheritance is a cornerstone of <strong>OOP</strong>, the concept is quite simple, a <code>Base</code> class contains members that are semantically common to N <code>Derived</code> classes. This mantains a semantic coherence while also avoiding repeated code and keeping the behavior definition on a single place easying code mantainance.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> data)</span><br><span class="line">    : foo_&#123;data&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">base_public</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protected_method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> kappa_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> foo_; <span class="comment">//As it is private it cannot be accessed from Derived</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> data)</span><br><span class="line">    : Base&#123;data&#125; <span class="comment">// First needs to initialize Base</span></span><br><span class="line">    , bar_&#123;<span class="number">22</span>&#125;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derived_public</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Can access protected members from Base</span></span><br><span class="line">        <span class="built_in">protected_method</span>();</span><br><span class="line">        kappa_ = bar_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> bar_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize object</span></span><br><span class="line">    Derived my_obj&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    my_obj.<span class="built_in">base_public</span>();</span><br><span class="line">    my_obj.<span class="built_in">derived_public</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The previous example makes use of inheritance only for code reuse, but <strong>inheritance</strong> can be much more powerful than that.</p><h2 id="Static-Dynamic-Polimorphism"><a href="#Static-Dynamic-Polimorphism" class="headerlink" title="Static &amp; Dynamic Polimorphism"></a>Static &amp; Dynamic Polimorphism</h2><p>We’re going to introduce 2 new concepts of <strong>OOP</strong>, <strong>static polimorphism</strong> and <strong>dynamic polimorphism</strong> . In C++, Polimorphism can be applied to: <strong>functions</strong> and <strong>operators</strong>.</p><p>Both can be resolved in 1 of 2 ways:</p><ul><li><strong>In compile-time(Static Polimorphism)</strong>: <strong>function&#x2F;operator</strong> calls are resolved by the <strong>compiler</strong>, its also present in <strong>templates (C++ generics)</strong> and forced with <strong>CRTP (Curiously Recursive Template Pattern)</strong> both will be explored in a later course.</li><li><strong>In runtime(Dynamic Polimorphism)</strong>: function calls are resolved in runtime</li></ul><p>Let’s take a closer look on each type of polymorphism and explain how and when to use them.</p><h3 id="Static-Polimorphism-Function-and-Operator-Overload"><a href="#Static-Polimorphism-Function-and-Operator-Overload" class="headerlink" title="Static Polimorphism: Function and Operator Overload"></a>Static Polimorphism: Function and Operator Overload</h3><p>In this post we will explore 2 ways of applying <strong>Static Polimorphism</strong>, these are <strong>Function Overloads</strong> and <strong>Operator Overloads</strong>.</p><p><strong>Function Overloading</strong> is a feature in <strong>OOP</strong> where 2 or more functions have the same name but different behave differently for different parameters. These functions are said to be <strong>overloaded</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Overloaded functions</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Static Polimorphism</strong> is also archieved by <strong>operator overloading</strong>. In a nutshell in C++ we can provide the operators(+,-,&lt;&lt;,&gt;&gt;…) specific meaning.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data)</span><br><span class="line">    : data_&#123;data&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overloaded == operator</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyClass&amp; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// First check if we&#x27;re comparing it with itself</span></span><br><span class="line">        <span class="comment">// this is usually a good practice with operators</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> data_ == right.data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize object</span></span><br><span class="line">    MyClass foo&#123;<span class="number">42</span>&#125;, bar&#123;<span class="number">22</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foo == bar)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;equal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;not equal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Dynamic-Polimorphism-Virtual-methods"><a href="#Dynamic-Polimorphism-Virtual-methods" class="headerlink" title="Dynamic Polimorphism: Virtual methods"></a>Dynamic Polimorphism: Virtual methods</h3><p><strong>Dynamic Polimorphism</strong>, also known as <strong>late binding</strong> in contrast to <strong>static polymorphism</strong> it is resolved at <strong>runtime</strong>. This has many benefits as we could change the behavior of a method from a Base depending on <strong>specializations</strong> of each Derived object.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> data)</span><br><span class="line">    : foo_&#123;data&#125;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">base_public</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Function can be called from the Base but execute Derived specific</span></span><br><span class="line">        <span class="comment">// implementations</span></span><br><span class="line">        <span class="built_in">my_fun</span>();</span><br><span class="line">        <span class="built_in">my_pure_fun</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">my_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base myfun implementation&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is called a Virtual method, it has a &quot;default&quot; implementation</span></span><br><span class="line">    <span class="comment">// than can be overriden in its specializations</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is called a Pure Virtual method, any Derived object MUST</span></span><br><span class="line">    <span class="comment">// implement a specialization</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">my_pure_fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kappa_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> foo_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> data)</span><br><span class="line">    : Base&#123;data&#125; <span class="comment">// First needs to initialize Base</span></span><br><span class="line">    , bar_&#123;<span class="number">22</span>&#125;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derived_public</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Can access protected members from Base</span></span><br><span class="line">        kappa_ = bar_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">my_fun</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Overriding my_fun&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Derived specific implementation of pure virtual functions</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">my_pure_fun</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pure method overriden&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> bar_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base obj&#123;<span class="number">42</span>&#125;; <span class="comment">// Polymorphic behavior</span></span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">base_public</span>(); <span class="comment">// Calls Base but dispatches to Derived implementations</span></span><br><span class="line">    obj.<span class="built_in">my_fun</span>(); <span class="comment">// Calls Derives as it is overriding it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Well, I think we’ve found where the ++ in C++ was.&lt;br&gt;I could agree with this statement, at least in its origins, C++ has evolved to be a superset of C that quite revamps it introducing modern concepts. But first things first.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 3. Functions</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-3-Functions/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-3-Functions/</id>
    <published>2025-08-17T00:00:00.000Z</published>
    <updated>2025-08-17T18:02:27.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>Functions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability.</p><span id="more"></span><h1 id="Function-syntaxis-and-usage"><a href="#Function-syntaxis-and-usage" class="headerlink" title="Function syntaxis and usage"></a>Function syntaxis and usage</h1><p>In C++ functions are composed by:</p><p><strong>return_type</strong> <em>function_name</em>(<strong>param_type</strong> <em>param_name</em>)</p><p>This example ilustrates basic use cases of functions:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Do things...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return values can also be used to initialize variables and update existing ones</span></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">sum2</span>(<span class="number">22</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Function-parameters-pass"><a href="#Function-parameters-pass" class="headerlink" title="Function parameters pass"></a>Function parameters pass</h1><p>Function parameters are passed into the function scope essentially in one of two ways:</p><ul><li><strong>Value</strong> <code>void foo(param_type param_name)</code></li><li><strong>Reference</strong> <code>void foo(param_type&amp; param_name param_type2* param_name2)</code></li></ul><p>This is a key concept in C++ both on optimization and design let’s delve deep into the details and differences between both.</p><h2 id="Pass-by-value"><a href="#Pass-by-value" class="headerlink" title="Pass by value"></a>Pass by value</h2><p>Passing a value through parameter <strong>involves making a copy of the original</strong> data to be used only during the function scope. This means that any changes on these objects during the function scope will be lost. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="built_in">foo</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 42 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Although when dealing with primitives this copy is negligible, with larger objects; allocation of considerable memory in frequently called functions, can slow down run-time execution by a considerable amount. </p><h2 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h2><p>Passing a parameter through reference (friendly reminder that references are pointers), involves <strong>that only the memory address is passed to the function scope</strong>, therefore, any changes made within the function scope will be made to the same object that was being passed by parameter in the first place. In other words, changes within the function scope are persistent.   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span> <span class="params">(<span class="type">int</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 12</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bar</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 4 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parameter pass by reference, as we are only passing a memory address, is quite cheap and efficient. But involves potential unintended value modifications. </p><p>It is that why a balance has to be archieved, where we, as developers should aim to optimize for performace while ensuring safe memory and data coherence.  </p><h2 id="Function-Pass-Optimization"><a href="#Function-Pass-Optimization" class="headerlink" title="Function Pass Optimization"></a>Function Pass Optimization</h2><p>As seen in previous points, the type of parameter pass if not managed correctly can take a considerable impact in runtime. Therefore it is necessary to know when to use one of another. </p><p>Copying (<em>Deep copying to be more precise</em>) is expensive, only exception are primitive types where copying a number and copying a memory address are almost identical in cost. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Both functions are almost identical in cost </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This should be prefered</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although this is valid it adds unnecessary verbosity</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span> <span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For any other case and specially objects; these should be always passed by reference unless any other restriction is present. This presents a problem as mentioned earlier of unwanted modification or write access to data. This can be avoided by using the <code>const</code> keyword before the parameter type, <code>const type&amp;</code> will pass by reference while only allowing read access.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allows read &amp; write</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only allows read</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Functions&quot;&gt;&lt;a href=&quot;#Functions&quot; class=&quot;headerlink&quot; title=&quot;Functions&quot;&gt;&lt;/a&gt;Functions&lt;/h1&gt;&lt;p&gt;Functions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 2. Compound Types and Memory</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-2-Compound-types-and-memory/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-2-Compound-types-and-memory/</id>
    <published>2025-08-16T00:00:00.000Z</published>
    <updated>2025-08-17T18:01:49.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Compound-Types"><a href="#Compound-Types" class="headerlink" title="Compound Types"></a>Compound Types</h1><p>So far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory.</p><span id="more"></span><p>We’ll first explore two foundational building blocks of structured data:</p><ul><li><strong>Arrays</strong></li><li><strong>Structs</strong></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays are one of the simplest memory structures in C and C++. They represent a contiguous block of memory, where elements of the same type are stored sequentially. Depending on how they’re declared, arrays can reside on the stack, in static storage, or be dynamically allocated in the heap.</p><p>Let’s see an example of its syntax:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates enough memory to store 5 integers</span></span><br><span class="line"><span class="type">int</span> foo[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocates enough memory to store the following list</span></span><br><span class="line"><span class="type">int</span> bar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>Being contiguous blocks of memory arrays support random access:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> foo[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo[<span class="number">2</span>] = <span class="number">42</span>; <span class="comment">// Now foo stores &#123;1,2,42&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>Structs are a way to group different types of data together into a single compound type. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supports only list-initialization</span></span><br><span class="line">Foo my_struct&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Access to a member variable</span></span><br><span class="line">my_struct.a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h1 id="Introduction-to-Memory-Management"><a href="#Introduction-to-Memory-Management" class="headerlink" title="Introduction to Memory Management"></a>Introduction to Memory Management</h1><p>C&#x2F;C++ are mid-level languages, this means that while they keep some sort of abstraction with the machine it also has tools to be able to interact directly with it. The main way of interacting with the machine is by altering and accessing directly its memory layout, this is done using <strong>pointers</strong>.</p><h2 id="Heap-and-Stack"><a href="#Heap-and-Stack" class="headerlink" title="Heap and Stack"></a>Heap and Stack</h2><p>Heap and stack are regions of memory used by the application. </p><p><strong>Stack Memory</strong> is used for <strong>local variables and function call management</strong>.<br>When the function returns, this memory is automatically freed. Key characteristics:</p><ul><li>Fast allocation and deallocation.</li><li>Memory size is limited (usually a few MB).</li><li>Variables only live as long as the function is active.</li><li>Typical use: local variables, function parameters, return addresses</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x lives on the stack</span></span><br></pre></td></tr></table></figure><p><strong>Heap Memory</strong> is used for dynamic allocation, where you control the lifetime of data. Key characteristics:</p><ul><li>Slower to allocate&#x2F;deallocate than the stack.</li><li>Much larger than the stack.</li><li>Useful for objects whose size or lifetime isn’t known at compile time.</li><li><strong>Requires careful management to avoid memory leaks.</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);  <span class="comment">// allocated on the heap</span></span><br><span class="line"><span class="keyword">delete</span> ptr;              <span class="comment">// manually freed</span></span><br></pre></td></tr></table></figure><p>A rule of thumb is to avoid Heap memory allocations when possible, heap memory is slower and more dangerous, but indispensable in many applications.</p><h2 id="Heap-Memory-Management"><a href="#Heap-Memory-Management" class="headerlink" title="Heap Memory Management"></a>Heap Memory Management</h2><p>Heap memory requires manual management in C&#x2F;C++. </p><p>In C we have the following operators:</p><ul><li><code>malloc(size)</code> is used to dynamically allocate a block of memory on the heap.</li><li><code>memcpy(dest, source, size)</code> is used to copy a block of memory from one location to another.</li><li><code>free(ptr)</code> is used to release memory previously allocated on the heap.</li></ul><p>In C++ we have modern alternatives that usually work better than their C counterparts</p><ul><li><code>new</code> is used to dynamically allocate a block of memory on the heap.</li><li><code>delete</code> is used to release memory previously allocated on the heap.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new variable that holds the memory address that stores the value 42</span></span><br><span class="line"><span class="type">int</span>* foo = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frees the allocated memory</span></span><br><span class="line"><span class="keyword">delete</span> foo;</span><br></pre></td></tr></table></figure><h2 id="Heap-Memory-Access-Pointers"><a href="#Heap-Memory-Access-Pointers" class="headerlink" title="Heap Memory Access (Pointers *)"></a>Heap Memory Access (Pointers *)</h2><p>Working with heap memory requires pointers—variables that store memory addresses. Pointers allow you to access and manipulate dynamically allocated memory directly.</p><p>Let’s see an example of how pointers work:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* foo = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;; </span><br><span class="line"><span class="type">int</span>* bar = foo; <span class="comment">// modify the value through the pointer</span></span><br><span class="line"></span><br><span class="line">*bar = <span class="number">12</span>; <span class="comment">// de-references the value and changes it</span></span><br></pre></td></tr></table></figure><p>In the previous example we’ve introduced the concept of <code>de-reference</code> when using <code>*my_ptr</code> we are accessing the stored value, otherwise with <code>my_ptr</code> we would access the memory address directly. <code>de-reference</code> is used to access the pointers pointed memory for both read and write.</p><p>Pointers can also be initialized as <code>nullptr</code> allowing for dynamic allocation:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> b &#123;<span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="type">int</span>&#123;&amp;b&#125;;</span><br></pre></td></tr></table></figure><p>Although, <code>nullptr</code> access will generate a critical error in form of a segmentation fault and exit the application inmediately. Fortunately the following concept offers safer memory access by demanding a valid address on initialization.</p><h2 id="Heap-Memory-Access-References"><a href="#Heap-Memory-Access-References" class="headerlink" title="Heap Memory Access (References &amp;)"></a>Heap Memory Access (References &amp;)</h2><p>A reference is an alias for an existing variable. Unlike pointers, references cannot be null and must be initialized when declared. References are often safer and more convenient than pointers, but they cannot be used for dynamic memory allocation themselves.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure><h2 id="Syntax-Cheatsheet"><a href="#Syntax-Cheatsheet" class="headerlink" title="Syntax Cheatsheet"></a>Syntax Cheatsheet</h2><p>C++ syntax can be confusing when dealing with pointers, here is a brief reminder of how to use it:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// for memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="type">int</span> a &#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* b &#123;<span class="literal">nullptr</span>&#125;;       <span class="comment">// pointer initialized to null</span></span><br><span class="line">    <span class="type">int</span>&amp; c &#123;a&#125;;             <span class="comment">// reference to a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign pointer to address of a</span></span><br><span class="line">    b = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access values</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer b holds address: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced value *b: &quot;</span> &lt;&lt; *b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dynamic memory allocation</span></span><br><span class="line">    <span class="type">int</span>* heapInt = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>); <span class="comment">// allocate on heap</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heap value: &quot;</span> &lt;&lt; *heapInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify through pointer</span></span><br><span class="line">    *heapInt = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified heap value: &quot;</span> &lt;&lt; *heapInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free memory</span></span><br><span class="line">    <span class="keyword">delete</span> heapInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrays on heap</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array element arr[1]: &quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy memory (like memcpy)</span></span><br><span class="line">    <span class="type">int</span> copy[<span class="number">3</span>];</span><br><span class="line">    std::<span class="built_in">memcpy</span>(copy, arr, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied array element copy[1]: &quot;</span> &lt;&lt; copy[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free array memory</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Key Points:</p><ul><li>“*” is used to dereference a pointer.</li><li>&amp; gives the address of a variable.</li><li>References (int&amp;) are safer aliases; pointers can be null or reassigned.</li><li>Use new&#x2F;delete for dynamic memory, new[]&#x2F;delete[] for arrays.</li><li>memcpy can copy raw memory, useful for structs or arrays.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Compound-Types&quot;&gt;&lt;a href=&quot;#Compound-Types&quot; class=&quot;headerlink&quot; title=&quot;Compound Types&quot;&gt;&lt;/a&gt;Compound Types&lt;/h1&gt;&lt;p&gt;So far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CudaThing</title>
    <link href="https://victorserranomoroder.github.io/article/CudaThing/"/>
    <id>https://victorserranomoroder.github.io/article/CudaThing/</id>
    <published>2025-08-10T00:00:00.000Z</published>
    <updated>2025-08-10T17:52:17.376Z</updated>
    
    
    
    
    <category term="article" scheme="https://victorserranomoroder.github.io/categories/article/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
    <category term="CUDA" scheme="https://victorserranomoroder.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 1 Fundamental types and operators</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1.1-Fundamental-types-and-operators/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1.1-Fundamental-types-and-operators/</id>
    <published>2025-08-09T00:00:00.000Z</published>
    <updated>2025-08-17T17:56:36.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Primitive-types"><a href="#Primitive-types" class="headerlink" title="Primitive types"></a>Primitive types</h1><p>Primitive types are simple types that represent data in its simplest form, all primitive types are <em>trivially copiable</em> and do not offer any functionality besides storing information in a meaningful way.</p><span id="more"></span><p>Primitives represent both meaning (a character, a number…) and a specific size (amount of bits that are needed to store them in memory). Some primitive data types are:</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>Integer data types represent whole numbers without a fractional or decimal part. They can be signed (positive, negative, or zero) or unsigned (only positive or zero).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 bits</span></span><br><span class="line"><span class="type">int</span> my_int = <span class="number">-42</span>; <span class="comment">// Can store negatives</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> my_uint= <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 64 bits</span></span><br><span class="line"><span class="type">long</span> my_long = <span class="number">-1024</span>; <span class="comment">// Can store negatives</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Character data types represent individual characters from a character set, like ASCII or Unicode. In C++, <code>char</code> is commonly used to represent characters.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> my_char = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">char</span> my_char = <span class="number">42</span>; <span class="comment">// Also valid! Chars are 8 bit numbers interpreted as ASCII</span></span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean data types represent binary values, typically used for true (1) or false (0) conditions. In C++, <code>bool</code> is used for Boolean data.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> my_true_bool = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> my_false_bool = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h3><p>Floating-point data types represent numbers with a fractional part. In C++, <code>float</code> is a single-precision floating-point type.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> my_float = <span class="number">42</span>f;</span><br></pre></td></tr></table></figure><h3 id="Double-Floating-Point"><a href="#Double-Floating-Point" class="headerlink" title="Double Floating Point"></a>Double Floating Point</h3><p>Double-precision floating-point data types are used to represent numbers with a larger range and higher precision compared to ‘float’. In C++, ‘double’ is commonly used.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> my_double = <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure><h3 id="Valueless-or-Void"><a href="#Valueless-or-Void" class="headerlink" title="Valueless or Void"></a>Valueless or Void</h3><p>The <code>void</code> data type in C++ is used to indicate that a function does not return any value or to declare generic pointers that do not point to a specific data type.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123; <span class="comment">// This function does not return a value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* genericPointer; <span class="comment">//We&#x27;ll get to that in a while...</span></span><br></pre></td></tr></table></figure><h2 id="Modern-primitive-types"><a href="#Modern-primitive-types" class="headerlink" title="Modern primitive types"></a>Modern primitive types</h2><p>More primitive types are available for improved precision and clarity, most of these are available by including for example <code>&lt;cstdint&gt;</code>, these will import types like <code>uint32_t</code>.  </p><p>These types are usually preferred than the standard primitives as they offer better readability. For example, lets say we want to store an 8 bit value (like a single channel RGB value):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> my_red_channel_value = <span class="number">125</span>;</span><br></pre></td></tr></table></figure><p>The only primitive type that stores an 8 bit value is a <code>char</code>, we are matching its size but its meaning can (and will) be quite confusing for another reader, for this situations we can use <code>uint8_t</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">uint8_t</span> my_red_channel_value = <span class="number">125</span>;</span><br></pre></td></tr></table></figure><p>Under the hood it will behave the same but we have greatly improved the readability of the code.</p><h1 id="Variable-declaration-and-use-of-operators"><a href="#Variable-declaration-and-use-of-operators" class="headerlink" title="Variable declaration and use of operators"></a>Variable declaration and use of operators</h1><p>Variable declaration in C++ is quite straightforward:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> my_int, my_other_int;</span><br><span class="line"><span class="type">float</span> my_float, my_other_float;</span><br><span class="line"><span class="type">bool</span> my_bool;</span><br></pre></td></tr></table></figure><p>It can also be said with operator usage, C++ offers a rather large collection of operators that can be used by objects, and primitives, this is no different than calling a function, but in a more readable way.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12</span>, b=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> result = a + b; <span class="comment">// result = 42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_sum_function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> other_result = <span class="built_in">my_sum_function</span>(a,b); <span class="comment">// result = 42 </span></span><br></pre></td></tr></table></figure><h1 id="Type-inference-with-auto"><a href="#Type-inference-with-auto" class="headerlink" title="Type inference with auto"></a>Type inference with auto</h1><p>Type inference is a feature usually seen in more high-level languages like Python and javascript. Although C++ is a static language that doesn’t mean that we cannot use type inference in some situations to avoid verbose code. Let’s see an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This is a common case when dealing with iterators</span></span><br><span class="line">std::list&lt;MyLovelyObject&gt;::iterator it = my_list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Most would just prefer...</span></span><br><span class="line"><span class="keyword">auto</span> it = my_list.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>Be aware that type inference in C++ has its limitations, <code>auto</code> needs to receive data at the moment of declaration:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This won&#x27;t work</span></span><br><span class="line"><span class="keyword">auto</span> my_type;</span><br><span class="line"></span><br><span class="line">my_type = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Primitive-types&quot;&gt;&lt;a href=&quot;#Primitive-types&quot; class=&quot;headerlink&quot; title=&quot;Primitive types&quot;&gt;&lt;/a&gt;Primitive types&lt;/h1&gt;&lt;p&gt;Primitive types are simple types that represent data in its simplest form, all primitive types are &lt;em&gt;trivially copiable&lt;/em&gt; and do not offer any functionality besides storing information in a meaningful way.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
</feed>
