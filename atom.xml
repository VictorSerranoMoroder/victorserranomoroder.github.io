<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Victor&#39;s Personal Page</title>
  
  
  <link href="https://victorserranomoroder.github.io/atom.xml" rel="self"/>
  
  <link href="https://victorserranomoroder.github.io/"/>
  <updated>2025-08-17T17:58:39.913Z</updated>
  <id>https://victorserranomoroder.github.io/</id>
  
  <author>
    <name>Víctor Serrano Moroder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++Basics 4 Object-Oriented Programming in C++</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/</id>
    <published>2025-08-18T00:00:00.000Z</published>
    <updated>2025-08-17T17:58:39.913Z</updated>
    
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 3. Functions</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-3-Functions/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-3-Functions/</id>
    <published>2025-08-17T00:00:00.000Z</published>
    <updated>2025-08-17T18:02:27.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><p>Functions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability.</p><span id="more"></span><h1 id="Function-syntaxis-and-usage"><a href="#Function-syntaxis-and-usage" class="headerlink" title="Function syntaxis and usage"></a>Function syntaxis and usage</h1><p>In C++ functions are composed by:</p><p><strong>return_type</strong> <em>function_name</em>(<strong>param_type</strong> <em>param_name</em>)</p><p>This example ilustrates basic use cases of functions:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// Do things...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return values can also be used to initialize variables and update existing ones</span></span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">sum2</span>(<span class="number">22</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Function-parameters-pass"><a href="#Function-parameters-pass" class="headerlink" title="Function parameters pass"></a>Function parameters pass</h1><p>Function parameters are passed into the function scope essentially in one of two ways:</p><ul><li><strong>Value</strong> <code>void foo(param_type param_name)</code></li><li><strong>Reference</strong> <code>void foo(param_type&amp; param_name param_type2* param_name2)</code></li></ul><p>This is a key concept in C++ both on optimization and design let’s delve deep into the details and differences between both.</p><h2 id="Pass-by-value"><a href="#Pass-by-value" class="headerlink" title="Pass by value"></a>Pass by value</h2><p>Passing a value through parameter <strong>involves making a copy of the original</strong> data to be used only during the function scope. This means that any changes on these objects during the function scope will be lost. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value&#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="built_in">foo</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 42 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Although when dealing with primitives this copy is negligible, with larger objects; allocation of considerable memory in frequently called functions, can slow down run-time execution by a considerable amount. </p><h2 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h2><p>Passing a parameter through reference (friendly reminder that references are pointers), involves <strong>that only the memory address is passed to the function scope</strong>, therefore, any changes made within the function scope will be made to the same object that was being passed by parameter in the first place. In other words, changes within the function scope are persistent.   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span> <span class="params">(<span class="type">int</span>* val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 12</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bar</span>(value);</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl; <span class="comment">//Prints 4 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Parameter pass by reference, as we are only passing a memory address, is quite cheap and efficient. But involves potential unintended value modifications. </p><p>It is that why a balance has to be archieved, where we, as developers should aim to optimize for performace while ensuring safe memory and data coherence.  </p><h2 id="Function-Pass-Optimization"><a href="#Function-Pass-Optimization" class="headerlink" title="Function Pass Optimization"></a>Function Pass Optimization</h2><p>As seen in previous points, the type of parameter pass if not managed correctly can take a considerable impact in runtime. Therefore it is necessary to know when to use one of another. </p><p>Copying (<em>Deep copying to be more precise</em>) is expensive, only exception are primitive types where copying a number and copying a memory address are almost identical in cost. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Both functions are almost identical in cost </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This should be prefered</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although this is valid it adds unnecessary verbosity</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span> <span class="params">(<span class="type">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For any other case and specially objects; these should be always passed by reference unless any other restriction is present. This presents a problem as mentioned earlier of unwanted modification or write access to data. This can be avoided by using the <code>const</code> keyword before the parameter type, <code>const type&amp;</code> will pass by reference while only allowing read access.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allows read &amp; write</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only allows read</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Functions&quot;&gt;&lt;a href=&quot;#Functions&quot; class=&quot;headerlink&quot; title=&quot;Functions&quot;&gt;&lt;/a&gt;Functions&lt;/h1&gt;&lt;p&gt;Functions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 2. Compound Types and Memory</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1-2-Compound-types-and-memory/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1-2-Compound-types-and-memory/</id>
    <published>2025-08-16T00:00:00.000Z</published>
    <updated>2025-08-17T18:01:49.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Compound-Types"><a href="#Compound-Types" class="headerlink" title="Compound Types"></a>Compound Types</h1><p>So far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory.</p><span id="more"></span><p>We’ll first explore two foundational building blocks of structured data:</p><ul><li><strong>Arrays</strong></li><li><strong>Structs</strong></li></ul><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays are one of the simplest memory structures in C and C++. They represent a contiguous block of memory, where elements of the same type are stored sequentially. Depending on how they’re declared, arrays can reside on the stack, in static storage, or be dynamically allocated in the heap.</p><p>Let’s see an example of its syntax:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates enough memory to store 5 integers</span></span><br><span class="line"><span class="type">int</span> foo[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocates enough memory to store the following list</span></span><br><span class="line"><span class="type">int</span> bar[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>Being contiguous blocks of memory arrays support random access:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> foo[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo[<span class="number">2</span>] = <span class="number">42</span>; <span class="comment">// Now foo stores &#123;1,2,42&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>Structs are a way to group different types of data together into a single compound type. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supports only list-initialization</span></span><br><span class="line">Foo my_struct&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Access to a member variable</span></span><br><span class="line">my_struct.a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h1 id="Introduction-to-Memory-Management"><a href="#Introduction-to-Memory-Management" class="headerlink" title="Introduction to Memory Management"></a>Introduction to Memory Management</h1><p>C&#x2F;C++ are mid-level languages, this means that while they keep some sort of abstraction with the machine it also has tools to be able to interact directly with it. The main way of interacting with the machine is by altering and accessing directly its memory layout, this is done using <strong>pointers</strong>.</p><h2 id="Heap-and-Stack"><a href="#Heap-and-Stack" class="headerlink" title="Heap and Stack"></a>Heap and Stack</h2><p>Heap and stack are regions of memory used by the application. </p><p><strong>Stack Memory</strong> is used for <strong>local variables and function call management</strong>.<br>When the function returns, this memory is automatically freed. Key characteristics:</p><ul><li>Fast allocation and deallocation.</li><li>Memory size is limited (usually a few MB).</li><li>Variables only live as long as the function is active.</li><li>Typical use: local variables, function parameters, return addresses</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">42</span>;  <span class="comment">// x lives on the stack</span></span><br></pre></td></tr></table></figure><p><strong>Heap Memory</strong> is used for dynamic allocation, where you control the lifetime of data. Key characteristics:</p><ul><li>Slower to allocate&#x2F;deallocate than the stack.</li><li>Much larger than the stack.</li><li>Useful for objects whose size or lifetime isn’t known at compile time.</li><li><strong>Requires careful management to avoid memory leaks.</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);  <span class="comment">// allocated on the heap</span></span><br><span class="line"><span class="keyword">delete</span> ptr;              <span class="comment">// manually freed</span></span><br></pre></td></tr></table></figure><p>A rule of thumb is to avoid Heap memory allocations when possible, heap memory is slower and more dangerous, but indispensable in many applications.</p><h2 id="Heap-Memory-Management"><a href="#Heap-Memory-Management" class="headerlink" title="Heap Memory Management"></a>Heap Memory Management</h2><p>Heap memory requires manual management in C&#x2F;C++. </p><p>In C we have the following operators:</p><ul><li><code>malloc(size)</code> is used to dynamically allocate a block of memory on the heap.</li><li><code>memcpy(dest, source, size)</code> is used to copy a block of memory from one location to another.</li><li><code>free(ptr)</code> is used to release memory previously allocated on the heap.</li></ul><p>In C++ we have modern alternatives that usually work better than their C counterparts</p><ul><li><code>new</code> is used to dynamically allocate a block of memory on the heap.</li><li><code>delete</code> is used to release memory previously allocated on the heap.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates a new variable that holds the memory address that stores the value 42</span></span><br><span class="line"><span class="type">int</span>* foo = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frees the allocated memory</span></span><br><span class="line"><span class="keyword">delete</span> foo;</span><br></pre></td></tr></table></figure><h2 id="Heap-Memory-Access-Pointers"><a href="#Heap-Memory-Access-Pointers" class="headerlink" title="Heap Memory Access (Pointers *)"></a>Heap Memory Access (Pointers *)</h2><p>Working with heap memory requires pointers—variables that store memory addresses. Pointers allow you to access and manipulate dynamically allocated memory directly.</p><p>Let’s see an example of how pointers work:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* foo = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">42</span>&#125;; </span><br><span class="line"><span class="type">int</span>* bar = foo; <span class="comment">// modify the value through the pointer</span></span><br><span class="line"></span><br><span class="line">*bar = <span class="number">12</span>; <span class="comment">// de-references the value and changes it</span></span><br></pre></td></tr></table></figure><p>In the previous example we’ve introduced the concept of <code>de-reference</code> when using <code>*my_ptr</code> we are accessing the stored value, otherwise with <code>my_ptr</code> we would access the memory address directly. <code>de-reference</code> is used to access the pointers pointed memory for both read and write.</p><p>Pointers can also be initialized as <code>nullptr</code> allowing for dynamic allocation:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> b &#123;<span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> <span class="type">int</span>&#123;&amp;b&#125;;</span><br></pre></td></tr></table></figure><p>Although, <code>nullptr</code> access will generate a critical error in form of a segmentation fault and exit the application inmediately. Fortunately the following concept offers safer memory access by demanding a valid address on initialization.</p><h2 id="Heap-Memory-Access-References"><a href="#Heap-Memory-Access-References" class="headerlink" title="Heap Memory Access (References &amp;)"></a>Heap Memory Access (References &amp;)</h2><p>A reference is an alias for an existing variable. Unlike pointers, references cannot be null and must be initialized when declared. References are often safer and more convenient than pointers, but they cannot be used for dynamic memory allocation themselves.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure><h2 id="Syntax-Cheatsheet"><a href="#Syntax-Cheatsheet" class="headerlink" title="Syntax Cheatsheet"></a>Syntax Cheatsheet</h2><p>C++ syntax can be confusing when dealing with pointers, here is a brief reminder of how to use it:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// for memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="type">int</span> a &#123;<span class="number">42</span>&#125;;</span><br><span class="line">    <span class="type">int</span>* b &#123;<span class="literal">nullptr</span>&#125;;       <span class="comment">// pointer initialized to null</span></span><br><span class="line">    <span class="type">int</span>&amp; c &#123;a&#125;;             <span class="comment">// reference to a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign pointer to address of a</span></span><br><span class="line">    b = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access values</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Pointer b holds address: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Dereferenced value *b: &quot;</span> &lt;&lt; *b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dynamic memory allocation</span></span><br><span class="line">    <span class="type">int</span>* heapInt = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>); <span class="comment">// allocate on heap</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Heap value: &quot;</span> &lt;&lt; *heapInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify through pointer</span></span><br><span class="line">    *heapInt = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified heap value: &quot;</span> &lt;&lt; *heapInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free memory</span></span><br><span class="line">    <span class="keyword">delete</span> heapInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arrays on heap</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array element arr[1]: &quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy memory (like memcpy)</span></span><br><span class="line">    <span class="type">int</span> copy[<span class="number">3</span>];</span><br><span class="line">    std::<span class="built_in">memcpy</span>(copy, arr, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied array element copy[1]: &quot;</span> &lt;&lt; copy[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free array memory</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Key Points:</p><ul><li>“*” is used to dereference a pointer.</li><li>&amp; gives the address of a variable.</li><li>References (int&amp;) are safer aliases; pointers can be null or reassigned.</li><li>Use new&#x2F;delete for dynamic memory, new[]&#x2F;delete[] for arrays.</li><li>memcpy can copy raw memory, useful for structs or arrays.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Compound-Types&quot;&gt;&lt;a href=&quot;#Compound-Types&quot; class=&quot;headerlink&quot; title=&quot;Compound Types&quot;&gt;&lt;/a&gt;Compound Types&lt;/h1&gt;&lt;p&gt;So far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CudaThing</title>
    <link href="https://victorserranomoroder.github.io/article/CudaThing/"/>
    <id>https://victorserranomoroder.github.io/article/CudaThing/</id>
    <published>2025-08-10T00:00:00.000Z</published>
    <updated>2025-08-10T17:52:17.376Z</updated>
    
    
    
    
    <category term="article" scheme="https://victorserranomoroder.github.io/categories/article/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
    <category term="CUDA" scheme="https://victorserranomoroder.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>C++Basics 1 Fundamental types and operators</title>
    <link href="https://victorserranomoroder.github.io/cpp-course-basic/1.1-Fundamental-types-and-operators/"/>
    <id>https://victorserranomoroder.github.io/cpp-course-basic/1.1-Fundamental-types-and-operators/</id>
    <published>2025-08-09T00:00:00.000Z</published>
    <updated>2025-08-17T17:56:36.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Primitive-types"><a href="#Primitive-types" class="headerlink" title="Primitive types"></a>Primitive types</h1><p>Primitive types are simple types that represent data in its simplest form, all primitive types are <em>trivially copiable</em> and do not offer any functionality besides storing information in a meaningful way.</p><span id="more"></span><p>Primitives represent both meaning (a character, a number…) and a specific size (amount of bits that are needed to store them in memory). Some primitive data types are:</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>Integer data types represent whole numbers without a fractional or decimal part. They can be signed (positive, negative, or zero) or unsigned (only positive or zero).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 bits</span></span><br><span class="line"><span class="type">int</span> my_int = <span class="number">-42</span>; <span class="comment">// Can store negatives</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> my_uint= <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 64 bits</span></span><br><span class="line"><span class="type">long</span> my_long = <span class="number">-1024</span>; <span class="comment">// Can store negatives</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>Character data types represent individual characters from a character set, like ASCII or Unicode. In C++, <code>char</code> is commonly used to represent characters.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> my_char = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="type">char</span> my_char = <span class="number">42</span>; <span class="comment">// Also valid! Chars are 8 bit numbers interpreted as ASCII</span></span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean data types represent binary values, typically used for true (1) or false (0) conditions. In C++, <code>bool</code> is used for Boolean data.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> my_true_bool = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> my_false_bool = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h3><p>Floating-point data types represent numbers with a fractional part. In C++, <code>float</code> is a single-precision floating-point type.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> my_float = <span class="number">42</span>f;</span><br></pre></td></tr></table></figure><h3 id="Double-Floating-Point"><a href="#Double-Floating-Point" class="headerlink" title="Double Floating Point"></a>Double Floating Point</h3><p>Double-precision floating-point data types are used to represent numbers with a larger range and higher precision compared to ‘float’. In C++, ‘double’ is commonly used.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> my_double = <span class="number">3.141592653589793</span>;</span><br></pre></td></tr></table></figure><h3 id="Valueless-or-Void"><a href="#Valueless-or-Void" class="headerlink" title="Valueless or Void"></a>Valueless or Void</h3><p>The <code>void</code> data type in C++ is used to indicate that a function does not return any value or to declare generic pointers that do not point to a specific data type.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123; <span class="comment">// This function does not return a value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* genericPointer; <span class="comment">//We&#x27;ll get to that in a while...</span></span><br></pre></td></tr></table></figure><h2 id="Modern-primitive-types"><a href="#Modern-primitive-types" class="headerlink" title="Modern primitive types"></a>Modern primitive types</h2><p>More primitive types are available for improved precision and clarity, most of these are available by including for example <code>&lt;cstdint&gt;</code>, these will import types like <code>uint32_t</code>.  </p><p>These types are usually preferred than the standard primitives as they offer better readability. For example, lets say we want to store an 8 bit value (like a single channel RGB value):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> my_red_channel_value = <span class="number">125</span>;</span><br></pre></td></tr></table></figure><p>The only primitive type that stores an 8 bit value is a <code>char</code>, we are matching its size but its meaning can (and will) be quite confusing for another reader, for this situations we can use <code>uint8_t</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">uint8_t</span> my_red_channel_value = <span class="number">125</span>;</span><br></pre></td></tr></table></figure><p>Under the hood it will behave the same but we have greatly improved the readability of the code.</p><h1 id="Variable-declaration-and-use-of-operators"><a href="#Variable-declaration-and-use-of-operators" class="headerlink" title="Variable declaration and use of operators"></a>Variable declaration and use of operators</h1><p>Variable declaration in C++ is quite straightforward:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> my_int, my_other_int;</span><br><span class="line"><span class="type">float</span> my_float, my_other_float;</span><br><span class="line"><span class="type">bool</span> my_bool;</span><br></pre></td></tr></table></figure><p>It can also be said with operator usage, C++ offers a rather large collection of operators that can be used by objects, and primitives, this is no different than calling a function, but in a more readable way.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12</span>, b=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> result = a + b; <span class="comment">// result = 42</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_sum_function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> other_result = <span class="built_in">my_sum_function</span>(a,b); <span class="comment">// result = 42 </span></span><br></pre></td></tr></table></figure><h1 id="Type-inference-with-auto"><a href="#Type-inference-with-auto" class="headerlink" title="Type inference with auto"></a>Type inference with auto</h1><p>Type inference is a feature usually seen in more high-level languages like Python and javascript. Although C++ is a static language that doesn’t mean that we cannot use type inference in some situations to avoid verbose code. Let’s see an example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This is a common case when dealing with iterators</span></span><br><span class="line">std::list&lt;MyLovelyObject&gt;::iterator it = my_list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Most would just prefer...</span></span><br><span class="line"><span class="keyword">auto</span> it = my_list.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>Be aware that type inference in C++ has its limitations, <code>auto</code> needs to receive data at the moment of declaration:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This won&#x27;t work</span></span><br><span class="line"><span class="keyword">auto</span> my_type;</span><br><span class="line"></span><br><span class="line">my_type = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Primitive-types&quot;&gt;&lt;a href=&quot;#Primitive-types&quot; class=&quot;headerlink&quot; title=&quot;Primitive types&quot;&gt;&lt;/a&gt;Primitive types&lt;/h1&gt;&lt;p&gt;Primitive types are simple types that represent data in its simplest form, all primitive types are &lt;em&gt;trivially copiable&lt;/em&gt; and do not offer any functionality besides storing information in a meaningful way.&lt;/p&gt;</summary>
    
    
    
    <category term="cpp-course-basic" scheme="https://victorserranomoroder.github.io/categories/cpp-course-basic/"/>
    
    
    <category term="C++" scheme="https://victorserranomoroder.github.io/tags/C/"/>
    
  </entry>
  
</feed>
