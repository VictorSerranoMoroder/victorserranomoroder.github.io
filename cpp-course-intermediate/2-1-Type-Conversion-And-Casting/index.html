<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C++Medium - Type Conversion and Object Casting - Victor&#039;s Personal Page</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Victor&#039;s Personal Page"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Victor&#039;s Personal Page"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or int"><meta property="og:type" content="blog"><meta property="og:title" content="C++Medium - Type Conversion and Object Casting"><meta property="og:url" content="https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/"><meta property="og:site_name" content="Victor&#039;s Personal Page"><meta property="og:description" content="Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or int"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://victorserranomoroder.github.io/img/og_image.png"><meta property="article:published_time" content="2025-11-10T00:00:00.000Z"><meta property="article:modified_time" content="2025-11-21T12:04:36.595Z"><meta property="article:author" content="Víctor Serrano Moroder"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://victorserranomoroder.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/"},"headline":"C++Medium - Type Conversion and Object Casting","image":["https://victorserranomoroder.github.io/img/og_image.png"],"datePublished":"2025-11-10T00:00:00.000Z","dateModified":"2025-11-21T12:04:36.595Z","author":{"@type":"Person","name":"Víctor Serrano Moroder"},"publisher":{"@type":"Organization","name":"Victor's Personal Page","logo":{"@type":"ImageObject","url":"https://victorserranomoroder.github.io/img/logo.svg"}},"description":"Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or int"}</script><link rel="canonical" href="https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Victor's Personal Page" type="application/atom+xml">
</head><body class="is-3-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/" alt="Victor&#039;s Personal Page" height="28"><img class="logo-img-dark" src="/" alt="Victor&#039;s Personal Page" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/curriculum">Curriculum</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/categories/article">Articles</a><a class="navbar-item" href="/cpp-course">C++ Course</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-11-10T00:00:00.000Z" title="11/10/2025, 12:00:00 AM">10-11-2025</time></span><span class="level-item"><a class="link-muted" href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></span><span class="level-item">9 minutes read (About 1322 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">C++Medium - Type Conversion and Object Casting</h1><div class="content"><p>Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or interfacing with APIs, type conversions determine how data is interpreted and how objects behave.</p>
<h1 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h1><p>Type conversion occurs whenever a value of one type is transformed into another type. C++ supports two broad categories.</p>
<h2 id="Implicit-Conversions"><a href="#Implicit-Conversions" class="headerlink" title="Implicit Conversions"></a>Implicit Conversions</h2><p>These occur without writing a cast:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a &#123;<span class="number">42.42</span>&#125;;</span><br><span class="line"><span class="type">int</span> b&#123;a&#125;; <span class="comment">// a is implicitly converted to double but values can be truncated due to narrowing conversion: b = 42</span></span><br></pre></td></tr></table></figure>
<p>As you can tell, in the previous example <code>b</code> losses the decimal data from <code>a</code>, <strong>safe convertion does not avoid data loss</strong>. Implicit conversions aim to be safe, but narrowing conversions (like <code>double</code> → <code>int</code>) may still happen and can silently lose data.</p>
<h2 id="Explicit-Conversions"><a href="#Explicit-Conversions" class="headerlink" title="Explicit Conversions"></a>Explicit Conversions</h2><p>As it names suggest explicit type conversions need the programmer to manually change data from one type to another. This is also known as <strong>Type Casting</strong>.</p>
<p>There are 3 major ways in which we can use explicit conversion in C++:</p>
<ul>
<li><strong>C Notation</strong></li>
<li><strong>Function Notation</strong></li>
<li><strong>C++ Casts</strong></li>
</ul>
<p>As you will see the older C and C++ notations are discouraged because these notations hide the intent of the conversion and can silently perform dangerous reinterpretations. <strong>Prefer C++ casts because they make your intent explicit</strong>.</p>
<h3 id="C-Notation-discouraged"><a href="#C-Notation-discouraged" class="headerlink" title="C Notation (discouraged)"></a>C Notation (discouraged)</h3><p>As the name suggests, this type of casting is favored in C . It is also known as <strong>cast notation</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// (data_type)expression</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">double</span> my_double&#123;&#125;; <span class="comment">// Remember to not rely on default initialization!</span></span><br><span class="line">my_double = (<span class="type">double</span>)my_int;</span><br></pre></td></tr></table></figure>

<h3 id="Function-Notation-discouraged"><a href="#Function-Notation-discouraged" class="headerlink" title="Function Notation (discouraged)"></a>Function Notation (discouraged)</h3><p>We can also use the function-like notation to cast data from one type to another.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// data_type(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="number">12</span>&#125;;</span><br><span class="line"><span class="type">double</span> my_double&#123;&#125;;</span><br><span class="line"></span><br><span class="line">my_double = <span class="built_in">double</span>(my_int);</span><br></pre></td></tr></table></figure>

<h3 id="C-Casts"><a href="#C-Casts" class="headerlink" title="C++ Casts"></a>C++ Casts</h3><p>The most idiomatic way of dealing with type casting is by using <strong>C++ Casts</strong>, C++ offers four expressions for explicit type conversion:</p>
<ul>
<li><strong>static_cast</strong></li>
<li><strong>dynamic_cast</strong></li>
<li><strong>const_cast</strong></li>
<li><strong>reinterpret_cast</strong></li>
</ul>
<h2 id="The-key-of-using-C-casts-is-to-know-when-and-how-to-use-each-one-Let’s-explore-each-cast-understand-its-purpose-and-discuss-when-it-should-or-should-not-be-used"><a href="#The-key-of-using-C-casts-is-to-know-when-and-how-to-use-each-one-Let’s-explore-each-cast-understand-its-purpose-and-discuss-when-it-should-or-should-not-be-used" class="headerlink" title="The key of using C++ casts is to know when and how to use each one. Let’s explore each cast, understand its purpose, and discuss when it should or should not be used."></a>The key of using C++ casts is to know when and how to use each one. Let’s explore each cast, understand its purpose, and discuss when it should or should not be used.</h2><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>It is the most common and most versatile C++ cast. <code>static-cast</code> uses a combination of implicit of implicit and user-defined conversions to work properly. In practice this means that <strong>this cast is compile-time checked and mostly safe</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// static_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> my_double &#123;<span class="number">42.42</span>&#125;;</span><br><span class="line"><span class="type">int</span> my_int &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(my_double)&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use"><a href="#When-To-Use" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>For well-defined and <strong>compile checked</strong> conversions.</li>
<li>Numeric conversions.</li>
<li><strong>Upcasting</strong> in inheritance.</li>
<li>Calling <code>explicit</code> constructors.</li>
</ul>
<h5 id="When-not-to-use"><a href="#When-not-to-use" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>When <strong>downcasting</strong> polymorphic classes -&gt; use <code>dynamic_cast</code> instead.</li>
<li>When the conversion may be unsafe or ambiguous.</li>
</ul>
<hr>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>This cast should <strong>exclusively be used on polymorphic types</strong> (AKA, <em>classes with at least one virtual method</em>). The most common use case for <code>dynamic_cast</code> is on <strong>Downcasting</strong>. In practice this means that <strong>this cast performs a runtime safety check</strong> and prevents unsafe conversions by returning <code>nullptr</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// dynamic_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line"><span class="comment">// Perform Downcast from Base to Derived</span></span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (derived)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Conversion succesful</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Conversion failed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-1"><a href="#When-To-Use-1" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>When you need to <strong>downcast</strong>.</li>
<li>When dealing with class hierarchies and dynamic polymorphism.</li>
</ul>
<h5 id="When-not-to-use-1"><a href="#When-not-to-use-1" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>When dealing with non-polymorphic types.</li>
<li>When performance is critical. <code>dynamic_cast</code> can be expensive due to vtable lookups.</li>
</ul>
<hr>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>This cast expression adds or removes <code>const</code> or <code>volatile</code> qualifiers. Usage of this cast expression is reduced only to compatibility with legacy APIs and a few corner cases. The reason is that removing <code>const</code> from a truly constant object and then modifying it is <strong>undefined behavior</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// const_cast&lt;type_w/o_const&gt;(expression)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value &#123;<span class="number">42</span>&#125;;            <span class="comment">// a const int</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;value));   <span class="comment">// dangerous: UB if foo modifies it</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>; <span class="comment">// a non-const int</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* value = &amp;x;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;value)); <span class="comment">// safe: x was not originally const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-2"><a href="#When-To-Use-2" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>When passing const pointers to legacy APIs</li>
<li>Removing <code>const</code> from objects that originally were non-const</li>
</ul>
<h5 id="When-not-to-use-2"><a href="#When-not-to-use-2" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>Anytime modifying a truly <code>const</code> object.</li>
<li>In any other case the use of this cast is strongly discouraged.</li>
</ul>
<hr>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p><strong>This is most likely the most dangerous type of cast</strong>. It reinterprets the raw bits of a value or pointer as another <em>completely</em> unrelated type. Because it can easily break aliasing rules, type safety, and memory assumptions, use it only when you fully understand the implications.</p>
<p>It is good practice to be skeptical and cautious when encountering this casting expression on a code base and it should also be accompanied by a comment block justifying the use of this cast and why it is necessary.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Syntax:</span></span><br><span class="line"><span class="comment">/// reinterpret_cast&lt;new_type&gt;(expression)</span></span><br><span class="line"></span><br><span class="line">std::<span class="type">uint32_t</span> raw = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="comment">// Comment explaining why reinterpret_cast is necessary</span></span><br><span class="line"><span class="type">char</span>* bytes = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;raw);</span><br></pre></td></tr></table></figure>

<h5 id="When-To-Use-3"><a href="#When-To-Use-3" class="headerlink" title="When To Use:"></a>When To Use:</h5><ul>
<li>In low-level programming.</li>
<li>When dealing with hardware or network packets.</li>
</ul>
<h5 id="When-not-to-use-3"><a href="#When-not-to-use-3" class="headerlink" title="When not to use:"></a>When <em>not</em> to use:</h5><ul>
<li>Everywhere else.</li>
</ul>
<h3 id="TL-DR-Use-the-right-cast"><a href="#TL-DR-Use-the-right-cast" class="headerlink" title="TL;DR Use the right cast"></a>TL;DR Use the right cast</h3><ul>
<li>Prefer <code>static_cast</code> for normal, well-defined conversions.</li>
<li>Use <code>dynamic_cast</code> only when downcasting polymorphic objects and you need runtime safety.</li>
<li>Use <code>const_cast</code> only to interface with legacy APIs, never modify a truly const object.</li>
<li>Use <code>reinterpret_cast</code> <strong>only when absolutely necessary</strong> in low-level code, it is dangerous.</li>
<li><strong>Avoid C-style and function-style casts</strong> because they hide intent and may perform unsafe conversions.</li>
</ul>
<h1 id="Object-Casting-in-C"><a href="#Object-Casting-in-C" class="headerlink" title="Object Casting in C++"></a>Object Casting in C++</h1><p>When dealing with inheritance, C++ allows you to <strong>convert pointers and references between base and derived types</strong>. These conversions called <strong>object casting</strong>, are central to polymorphism, but must be used carefully to avoid undefined behavior.</p>
<h2 id="Upcasting"><a href="#Upcasting" class="headerlink" title="Upcasting"></a>Upcasting</h2><p>Upcasting is converting a <em>derived type to its base type</em>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DerivedA derived&#123;&#125;;</span><br><span class="line">Base* ptr = &amp;derived; <span class="comment">// Upcast — implicit and always safe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Quite useful to make heterogeneous containers</span></span><br><span class="line">std::list&lt;Base*&gt;list&#123;&#125;;</span><br><span class="line">list.<span class="built_in">push_back</span>(ptr);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="keyword">new</span> DerivedB&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>Upcasting works because a Derived object is a Base</strong> and <strong>it is always safe</strong>.</p>
<p>Calling virtual functions through Base* or Base&amp; dispatches to overridden Derived implementations.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line">    <span class="comment">// static_cast can be used but it can also be implicit</span></span><br><span class="line">    Base* ptr_b = <span class="built_in">static_cast</span>&lt;Base*&gt;(<span class="keyword">new</span> Derived&#123;&#125;);</span><br><span class="line">    ptr-&gt;<span class="built_in">foo</span>(); <span class="comment">// Prints Derived Foo</span></span><br><span class="line">    ptr_b-&gt;<span class="built_in">foo</span>(); <span class="comment">// Prints Derived Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Downcasting"><a href="#Downcasting" class="headerlink" title="Downcasting"></a>Downcasting</h2><p>Downcasting converts a base type to a derived type. <strong>Downcasting is not inherently safe</strong> because a Base* may not actually point to a Derived object. When done incorrectly, the behavior is undefined. <strong>For safe downcasting</strong>, C++ offers <code>dynamic_cast</code>, which relies on <strong>runtime type information (<code>RTTI</code>)</strong>.</p>
<p><code>RTTI</code> has its limitations:</p>
<ul>
<li>Works only with polymorphic types (at least one virtual function).</li>
<li>On pointer types:<ul>
<li><em>success</em> -&gt; valid pointer</li>
<li><em>failure</em> -&gt; <code>nullptr</code></li>
</ul>
</li>
<li>On reference types:<ul>
<li><em>failure</em> -&gt; throws <code>std::bad_cast</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* d_scast = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// Downcast, unsafe unless you KNOW the dynamic type</span></span><br><span class="line">Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b); <span class="comment">// Safe downcast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Success: b actually pointed to a Derived</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Failed: b was not a Derived</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-Slicing"><a href="#Object-Slicing" class="headerlink" title="Object Slicing"></a>Object Slicing</h2><p>Object slicing occurs when a derived object is <strong>assigned or passed by value</strong> into a base-type variable:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base b = d;   <span class="comment">// Slices off Derived-specific parts</span></span><br></pre></td></tr></table></figure>

<p><strong>The Base object receives only its own fields</strong>; all Derived state is lost.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> Derived&#123;&#125;;</span><br><span class="line">    <span class="comment">// Object is sliced and Derived specific info is lost</span></span><br><span class="line">    Base value = *ptr;</span><br><span class="line">    value.<span class="built_in">foo</span>(); <span class="comment">// Prints Base Foo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To avoid slicing:</p>
<ul>
<li>Pass by reference or pointer</li>
<li>Use smart pointers (<code>std::unique_ptr</code>, etc.)</li>
<li>Design classes for polymorphic use (virtual destructors, etc.)</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++Medium - Type Conversion and Object Casting</p><p><a href="https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/">https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Víctor Serrano Moroder</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>10-11-2025</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>21-11-2025</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/cpp-course-intermediate/post/"><span class="level-item">C++Medium - Ownership and Resource Management</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://victorserranomoroder.github.io/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/';
            this.page.identifier = 'cpp-course-intermediate/2-1-Type-Conversion-And-Casting/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'https-victorserranomoroder-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Víctor Serrano Moroder"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Víctor Serrano Moroder</p><p class="is-size-6 is-block">C++ Software Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Madrid, Spain</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/victorserranomoroder" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/victorserranomoroder"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LinkedIn" href="https://www.linkedin.com/in/v%C3%ADctor-serrano-moroder/"><i class="fab fa-linkedin"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Type-Conversion"><span class="level-left"><span class="level-item">1</span><span class="level-item">Type Conversion</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Implicit-Conversions"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Implicit Conversions</span></span></a></li><li><a class="level is-mobile" href="#Explicit-Conversions"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Explicit Conversions</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#C-Notation-discouraged"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">C Notation (discouraged)</span></span></a></li><li><a class="level is-mobile" href="#Function-Notation-discouraged"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Function Notation (discouraged)</span></span></a></li><li><a class="level is-mobile" href="#C-Casts"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">C++ Casts</span></span></a></li></ul></li><li><a class="level is-mobile" href="#The-key-of-using-C-casts-is-to-know-when-and-how-to-use-each-one-Let’s-explore-each-cast-understand-its-purpose-and-discuss-when-it-should-or-should-not-be-used"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">The key of using C++ casts is to know when and how to use each one. Let’s explore each cast, understand its purpose, and discuss when it should or should not be used.</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#static-cast"><span class="level-left"><span class="level-item">1.3.1.1</span><span class="level-item">static_cast</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#When-To-Use"><span class="level-left"><span class="level-item">1.3.1.1.1</span><span class="level-item">When To Use:</span></span></a></li><li><a class="level is-mobile" href="#When-not-to-use"><span class="level-left"><span class="level-item">1.3.1.1.2</span><span class="level-item">When not to use:</span></span></a></li></ul></li><li><a class="level is-mobile" href="#dynamic-cast"><span class="level-left"><span class="level-item">1.3.1.2</span><span class="level-item">dynamic_cast</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#When-To-Use-1"><span class="level-left"><span class="level-item">1.3.1.2.1</span><span class="level-item">When To Use:</span></span></a></li><li><a class="level is-mobile" href="#When-not-to-use-1"><span class="level-left"><span class="level-item">1.3.1.2.2</span><span class="level-item">When not to use:</span></span></a></li></ul></li><li><a class="level is-mobile" href="#const-cast"><span class="level-left"><span class="level-item">1.3.1.3</span><span class="level-item">const_cast</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#When-To-Use-2"><span class="level-left"><span class="level-item">1.3.1.3.1</span><span class="level-item">When To Use:</span></span></a></li><li><a class="level is-mobile" href="#When-not-to-use-2"><span class="level-left"><span class="level-item">1.3.1.3.2</span><span class="level-item">When not to use:</span></span></a></li></ul></li><li><a class="level is-mobile" href="#reinterpret-cast"><span class="level-left"><span class="level-item">1.3.1.4</span><span class="level-item">reinterpret_cast</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#When-To-Use-3"><span class="level-left"><span class="level-item">1.3.1.4.1</span><span class="level-item">When To Use:</span></span></a></li><li><a class="level is-mobile" href="#When-not-to-use-3"><span class="level-left"><span class="level-item">1.3.1.4.2</span><span class="level-item">When not to use:</span></span></a></li></ul></li></ul><li><a class="level is-mobile" href="#TL-DR-Use-the-right-cast"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">TL;DR Use the right cast</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Object-Casting-in-C"><span class="level-left"><span class="level-item">2</span><span class="level-item">Object Casting in C++</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Upcasting"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Upcasting</span></span></a></li><li><a class="level is-mobile" href="#Downcasting"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Downcasting</span></span></a></li><li><a class="level is-mobile" href="#Object-Slicing"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Object Slicing</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=g6xrmgy1n1m&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="g6xrmgy1n1m" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/article/"><span class="level-start"><span class="level-item">article</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/cpp-course-basic/"><span class="level-start"><span class="level-item">cpp-course-basic</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/cpp-course-intermediate/"><span class="level-start"><span class="level-item">cpp-course-intermediate</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-11-10T00:00:00.000Z">10-11-2025</time></p><p class="title"><a href="/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/">C++Medium - Type Conversion and Object Casting</a></p><p class="categories"><a href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-11-10T00:00:00.000Z">10-11-2025</time></p><p class="title"><a href="/cpp-course-intermediate/post/">C++Medium - Ownership and Resource Management</a></p><p class="categories"><a href="/categories/cpp-course-intermediate/">cpp-course-intermediate</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-09-10T00:00:00.000Z">10-09-2025</time></p><p class="title"><a href="/cpp-course-basic/1-5-Basic-Project-Structure/">C++Basics 5. Basic Project Structure</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-18T00:00:00.000Z">18-08-2025</time></p><p class="title"><a href="/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/">C++Basics 4. Object-Oriented Programming in C++</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-08-17T00:00:00.000Z">17-08-2025</time></p><p class="title"><a href="/cpp-course-basic/1-3-Functions/">C++Basics 3. Functions</a></p><p class="categories"><a href="/categories/cpp-course-basic/">cpp-course-basic</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/11/"><span class="level-start"><span class="level-item">November 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/09/"><span class="level-start"><span class="level-item">September 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/08/"><span class="level-start"><span class="level-item">August 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/" alt="Victor&#039;s Personal Page" height="28"><img class="logo-img-dark" src="/" alt="Victor&#039;s Personal Page" height="28"></a><p class="is-size-7"><span>&copy; 2025 Víctor Serrano Moroder</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2025</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>