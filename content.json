{"posts":[{"title":"C++Basics 2. Compound Types and Memory","text":"Compound TypesSo far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory. We’ll first explore two foundational building blocks of structured data: Arrays Structs ArraysArrays are one of the simplest memory structures in C and C++. They represent a contiguous block of memory, where elements of the same type are stored sequentially. Depending on how they’re declared, arrays can reside on the stack, in static storage, or be dynamically allocated in the heap. Let’s see an example of its syntax: 12345// Allocates enough memory to store 5 integersint foo[5];// Allocates enough memory to store the following listint bar[] = {1,2,3}; Being contiguous blocks of memory arrays support random access: 12345int foo[] = {1,2,3};foo[2] = 42; // Now foo stores {1,2,42} StructsStructs are a way to group different types of data together into a single compound type. 123456789101112struct Foo{ int a; int b; int c;};//Supports only list-initializationFoo my_struct{1,2,3};//Access to a member variablemy_struct.a = 12; Introduction to Memory ManagementC/C++ are mid-level languages, this means that while they keep some sort of abstraction with the machine it also has tools to be able to interact directly with it. The main way of interacting with the machine is by altering and accessing directly its memory layout, this is done using pointers. Heap and StackHeap and stack are regions of memory used by the application. Stack Memory is used for local variables and function call management.When the function returns, this memory is automatically freed. Key characteristics: Fast allocation and deallocation. Memory size is limited (usually a few MB). Variables only live as long as the function is active. Typical use: local variables, function parameters, return addresses 1int x = 42; // x lives on the stack Heap Memory is used for dynamic allocation, where you control the lifetime of data. Key characteristics: Slower to allocate/deallocate than the stack. Much larger than the stack. Useful for objects whose size or lifetime isn’t known at compile time. Requires careful management to avoid memory leaks. 12int* ptr = new int(42); // allocated on the heapdelete ptr; // manually freed A rule of thumb is to avoid Heap memory allocations when possible, heap memory is slower and more dangerous, but indispensable in many applications. Heap Memory ManagementHeap memory requires manual management in C/C++. In C we have the following operators: malloc(size) is used to dynamically allocate a block of memory on the heap. memcpy(dest, source, size) is used to copy a block of memory from one location to another. free(ptr) is used to release memory previously allocated on the heap. In C++ we have modern alternatives that usually work better than their C counterparts new is used to dynamically allocate a block of memory on the heap. delete is used to release memory previously allocated on the heap. 12345// Creates a new variable that holds the memory address that stores the value 42int* foo = new int{42};// Frees the allocated memorydelete foo; Heap Memory Access (Pointers *)Working with heap memory requires pointers—variables that store memory addresses. Pointers allow you to access and manipulate dynamically allocated memory directly. Let’s see an example of how pointers work: 1234int* foo = new int{42}; int* bar = foo; // modify the value through the pointer*bar = 12; // de-references the value and changes it In the previous example we’ve introduced the concept of de-reference when using *my_ptr we are accessing the stored value, otherwise with my_ptr we would access the memory address directly. de-reference is used to access the pointers pointed memory for both read and write. Pointers can also be initialized as nullptr allowing for dynamic allocation: 1234int* a = nullptr;int b {24};a = new int{&amp;b}; Although, nullptr access will generate a critical error in form of a segmentation fault and exit the application inmediately. Fortunately the following concept offers safer memory access by demanding a valid address on initialization. Heap Memory Access (References &amp;)A reference is an alias for an existing variable. Unlike pointers, references cannot be null and must be initialized when declared. References are often safer and more convenient than pointers, but they cannot be used for dynamic memory allocation themselves. 12int a = 42;int&amp; b = a; Syntax CheatsheetC++ syntax can be confusing when dealing with pointers, here is a brief reminder of how to use it: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt; // for memcpyint main() { // Initialization int a {42}; int* b {nullptr}; // pointer initialized to null int&amp; c {a}; // reference to a // Assign pointer to address of a b = &amp;a; // Access values std::cout &lt;&lt; &quot;Pointer b holds address: &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dereferenced value *b: &quot; &lt;&lt; *b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Reference c: &quot; &lt;&lt; c &lt;&lt; std::endl; // Dynamic memory allocation int* heapInt = new int(100); // allocate on heap std::cout &lt;&lt; &quot;Heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Modify through pointer *heapInt = 200; std::cout &lt;&lt; &quot;Modified heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Free memory delete heapInt; // Arrays on heap int* arr = new int[3]{1, 2, 3}; std::cout &lt;&lt; &quot;Array element arr[1]: &quot; &lt;&lt; arr[1] &lt;&lt; std::endl; // Copy memory (like memcpy) int copy[3]; std::memcpy(copy, arr, 3 * sizeof(int)); std::cout &lt;&lt; &quot;Copied array element copy[1]: &quot; &lt;&lt; copy[1] &lt;&lt; std::endl; // Free array memory delete[] arr; return 0;} Key Points: “*” is used to dereference a pointer. &amp; gives the address of a variable. References (int&amp;) are safer aliases; pointers can be null or reassigned. Use new/delete for dynamic memory, new[]/delete[] for arrays. memcpy can copy raw memory, useful for structs or arrays.","link":"/cpp-course-basic/1-2-Compound-types-and-memory/"},{"title":"C++Basics 3. Functions","text":"FunctionsFunctions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability. Function syntaxis and usageIn C++ functions are composed by: return_type function_name(param_type param_name) This example ilustrates basic use cases of functions: 123456789101112131415161718192021#include &lt;iostream&gt;void foo(){ /// Do things...}int sum2(int a, int b){ return a+b;}int main(){ foo(); // Return values can also be used to initialize variables and update existing ones int a = sum2(22,20); std::cout &lt;&lt; a &lt;&lt; std::endl;} Function parameters passFunction parameters are passed into the function scope essentially in one of two ways: Value void foo(param_type param_name) Reference void foo(param_type&amp; param_name param_type2* param_name2) This is a key concept in C++ both on optimization and design let’s delve deep into the details and differences between both. Pass by valuePassing a value through parameter involves making a copy of the original data to be used only during the function scope. This means that any changes on these objects during the function scope will be lost. 1234567891011void foo(int a){ a = 22;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 42 } Although when dealing with primitives this copy is negligible, with larger objects; allocation of considerable memory in frequently called functions, can slow down run-time execution by a considerable amount. Pass by ReferencePassing a parameter through reference (friendly reminder that references are pointers), involves that only the memory address is passed to the function scope, therefore, any changes made within the function scope will be made to the same object that was being passed by parameter in the first place. In other words, changes within the function scope are persistent. 123456789101112131415161718192021void foo(int&amp; val){ val = 12;}void bar (int* val){ val = 4;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 12 bar(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 4 } Parameter pass by reference, as we are only passing a memory address, is quite cheap and efficient. But involves potential unintended value modifications. It is that why a balance has to be archieved, where we, as developers should aim to optimize for performace while ensuring safe memory and data coherence. Function Pass OptimizationAs seen in previous points, the type of parameter pass if not managed correctly can take a considerable impact in runtime. Therefore it is necessary to know when to use one of another. Copying (Deep copying to be more precise) is expensive, only exception are primitive types where copying a number and copying a memory address are almost identical in cost. 1234567891011121314//Both functions are almost identical in cost // This should be preferedvoid foo(int value){ //...}// Although this is valid it adds unnecessary verbosityvoid bar (int&amp; value){ //...} For any other case and specially objects; these should be always passed by reference unless any other restriction is present. This presents a problem as mentioned earlier of unwanted modification or write access to data. This can be avoided by using the const keyword before the parameter type, const type&amp; will pass by reference while only allowing read access. 1234567891011// Allows read &amp; writevoid foo(std::string&amp; str){ //...}// Only allows readvoid bar(const std::string&amp; str){ //...}","link":"/cpp-course-basic/1-3-Functions/"},{"title":"C++Basics 4. Object-Oriented Programming in C++","text":"Well, I think we’ve found where the ++ in C++ was.I could agree with this statement, at least in its origins, C++ has evolved to be a superset of C that quite revamps it introducing modern concepts. But first things first. The building blocks of OOP, Objects and ResponsibilityC++ is by design an Object-Oriented Programming (OOP) language. OOP is a way of writing programs that organizes data and behavior into objects. An object groups together information (called attributes or member variables) and the actions that can be performed on it (called methods or member functions). This approach makes programs easier to structure, reuse, and maintain. A key principle in OOP design is encapsulation, which means that an object should hide its internal details and only expose what is necessary. Encapsulation helps reduce coupling, making objects more independent and easier to maintain. This prevents objects from reaching deeply into other objects’ internals, further reducing coupling and keeping the design clean. In C++, visibility specifiers are the main tool for enforcing encapsulation: public: members specified as public can be accessed from other objects freely. protected: members specified as protected can be accessed from derived objects. private: members specified as private cannot be accessed from other objects. After a brief dive into the dephts of applied design principles in C++, let’s see how C++ allows us to implement objects, let’s start with an previously visited concept. StructsWe’ve already explored the minimal expression of these objects when we talked about structs.These can behave as: Plain Old Data (POD) objects, in a nutshell, aggregates of data that share a semantic relationship. Objects structures that define not only semantically related data but also behavior in the form of member functions. Struct members have public visibility access by default. 12345678910111213141516171819struct MyAggregate{ // Both a,b are publicly accessible int a; int b; private: int c;};struct MyObject{ int a; int b; void foo() { // ... }}; ClassesClasses are pretty much identical to structs, but feature private default access to members. This is mainly the reason why in practice, classes are preferred over structs as they are seen as better suited for encapsulation. Lets see an example that showcases how classes work: 1234567891011121314151617181920212223242526272829303132class MyClass{ public: // Constructor MyClass(int data) : data_{data} { } int get_data() { foo(); // foo can be called as it is in the same class return data_; } private: void foo() { // ... } int data_;};int main(){ // Initialize object MyClass my_obj{42}; // Call to public function int result = my_obj.get_data(); // Returns 42} In these example we’ve “smoothly” introduced a concept that deserves its own section. Object ConstructorsConstructors are functions that define how an object has to be initialized. Although we are introducing this concept with classes they can be found in structs aswell. A constructor job is to initialize its members. In C++ constructors is good practice to initialize members by List initialization instead of relying on Default Initialization. (We’ll delve more deeply into initialization types in the following course). 123456789101112131415class MyClass{ public: MyClass(int data) : data_{data} //List initialized member { // Other has been default-initialized and then // we have assigned its value. Not optimal. other_ = data; } private: int data_; int other_;} Object DestructorsHaving explained constructors, its easier to understand destructors. Destructors are functions triggered when and object is deleted, depending on where the object is allocated in memory its destruction will be triggered by different reasons: stack: stack allocated objects are deleted when leaving its scope or when its owner deletes it. heap: heap allocated objects are deleted explicitly by a delete call. An important concept is destruction order, when an object is notified to be destroyed it must also notify the destruction of its members, and it does it in a very specific order. In C++ member destruction is triggered in an inverse initialization order or from the bottom to the top. This is important as in some cases it could derive in lifetime issues and it could hinder propper app exit among other subtle possible issues. After all members have been destroyed the object deletes itself. This is also a quick look at how RAII (Resource Adquisition Is Initialization) idiom (pattern) that we will explore in the following course together with the previously mentioned concepts. Let’s get back on track. 1234567891011121314151617181920212223class MyClass{ public: // Constructor initializes both members MyClass(int data) // Latest to destroy : stack_data_{data} , heap_data_{new int{data}} , object_a_{} // Latest to initialize, first to destroy { } // Class destructor ~MyClass() { // Heap allocated memory has to be explicitly deleted delete heap_data_; } private: int stack_data_; int* heap_data_; ObjectA object_a_;}; Inheritance in C++Inheritance is a cornerstone of OOP, the concept is quite simple, a Base class contains members that are semantically common to N Derived classes. This mantains a semantic coherence while also avoiding repeated code and keeping the behavior definition on a single place easying code mantainance. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Base{ public: // Constructor Base(int data) : foo_{data} { } void base_public() { //... } protected: void protected_method() { //... } int kappa_; private: int foo_; //As it is private it cannot be accessed from Derived};class Derived : public Base{ public: Derived(int data) : Base{data} // First needs to initialize Base , bar_{22} { } void derived_public() { // Can access protected members from Base protected_method(); kappa_ = bar_; } private: int bar_;};int main(){ // Initialize object Derived my_obj{42}; my_obj.base_public(); my_obj.derived_public();} The previous example makes use of inheritance only for code reuse, but inheritance can be much more powerful than that. Static &amp; Dynamic PolimorphismWe’re going to introduce 2 new concepts of OOP, static polimorphism and dynamic polimorphism . In C++, Polimorphism can be applied to: functions and operators. Both can be resolved in 1 of 2 ways: In compile-time(Static Polimorphism): function/operator calls are resolved by the compiler, its also present in templates (C++ generics) and forced with CRTP (Curiously Recursive Template Pattern) both will be explored in a later course. In runtime(Dynamic Polimorphism): function calls are resolved in runtime Let’s take a closer look on each type of polymorphism and explain how and when to use them. Static Polimorphism: Function and Operator OverloadIn this post we will explore 2 ways of applying Static Polimorphism, these are Function Overloads and Operator Overloads. Function Overloading is a feature in OOP where 2 or more functions have the same name but different behave differently for different parameters. These functions are said to be overloaded. 1234567891011class MyClass{ public: MyClass() = default; private: // Overloaded functions void foo(); void foo(int a); void foo(float b);}; Static Polimorphism is also archieved by operator overloading. In a nutshell in C++ we can provide the operators(+,-,&lt;&lt;,&gt;&gt;…) specific meaning. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;class MyClass{ public: MyClass(int data) : data_{data} { } // Overloaded == operator bool operator==(const MyClass&amp; right) { // First check if we're comparing it with itself // this is usually a good practice with operators if (this == &amp;right) return true; return data_ == right.data_; } private: int data_;};int main(){ // Initialize object MyClass foo{42}, bar{22}; if (foo == bar) { std::cout &lt;&lt; &quot;equal&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;not equal&quot; &lt;&lt; std::endl; }} Dynamic Polimorphism: Virtual methodsDynamic Polimorphism, also known as late binding in contrast to static polymorphism it is resolved at runtime. This has many benefits as we could change the behavior of a method from a Base depending on specializations of each Derived object. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Base{ public: // Constructor Base(int data) : foo_{data} { } void base_public() { // Function can be called from the Base but execute Derived specific // implementations my_fun(); my_pure_fun(); } virtual void my_fun() { std::cout &lt;&lt; &quot;Base myfun implementation&quot; &lt;&lt; std::endl; } protected: // This is called a Virtual method, it has a &quot;default&quot; implementation // than can be overriden in its specializations // This is called a Pure Virtual method, any Derived object MUST // implement a specialization virtual void my_pure_fun() = 0; int kappa_; private: int foo_;};class Derived : public Base{ public: Derived(int data) : Base{data} // First needs to initialize Base , bar_{22} { } void derived_public() { // Can access protected members from Base kappa_ = bar_; } virtual void my_fun() override { std::cout &lt;&lt; &quot;Overriding my_fun&quot; &lt;&lt; std::endl; } // Derived specific implementation of pure virtual functions virtual void my_pure_fun() override { std::cout &lt;&lt; &quot;Pure method overriden&quot; &lt;&lt; std::endl; } private: int bar_;};int main(){ Base obj{42}; // Polymorphic behavior obj.base_public(); // Calls Base but dispatches to Derived implementations obj.my_fun(); // Calls Derives as it is overriding it}","link":"/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/"},{"title":"C++Basics 5. Basic Project Structure","text":"If you’ve reached this far, congratulations! You can now write simple C++ applications and apply basic OOP concepts. But real-world applications are organized quite differently from the small examples you’ve seen so far. C and C++ have a distinctive way of structuring code. In this post we’ll explore how to lay out a simple but scalable C++ project, covering headers, source files and some basic code organization. Headers and Source FilesIn small examples you’ve probably written everything inside a single .cpp file. This is fine for proofs of concept and small prototypes, but it quickly becomes unmanageable as your codebase grows. C++ projects usually separate the interface (declarations) from the implementation (definitions). Header files (.hpp)Header files act as an interface: they tell other parts of your program how to use your code without exposing how it works internally. They typically contain declarations of classes, functions, constants, and templates. A key aspect of header files is that they are not compiled on their own. In fact, if both the declarations and definitions are stored entirely within a header (a “header-only” library), it can be used in any project simply by including the header, without linking against a compiled library. These self-contained libraries are praised for being easy to integrate, examples include stb_image and toml++. 1234567891011// MyClass.hppclass MyClass{ public: MyClass(int data); void set_data(int data); int get_data(); private: int data_;}; Source Files (.cpp)Source files define how the declarations in the .hpp actually work. They implement function bodies and class methods. The corresponding header is included at the top so the compiler knows the declarations you’re defining. Source files are compiled and then linked together to form an executable or library. 1234567891011121314151617// MyClass.cpp#include &quot;MyClass.hpp&quot;MyClass::MyClass(int data): data_{data}{}void MyClass::set_data(int data){ data_ = data;}int MyClass::get_data(){ return data_;} Project OrganizationProject folder structure and code organization can vary widely depending on project requirements and team preferences. So I’ll keep this section short. This can also depend on whether or not the project is going to be used as a library or a fully fledged application. A small C++ library usually keeps .hpp and .cpp split, this is because if any program tries to use your library it will need clear access to its public interface and remember that .hpp files pretty much fulfills the public interface role. 123456/build # Generated build artifacts (object files, binaries)CMakeLists.txt # Project build definition file/docs # Project docs (README, API docs)/include # Public header files (.hpp)/src # Source files (.cpp) and private headers/tests # Test files for unit testing A small C++ application usually groups both .hpp and .cpp together as there is no need to share its functionality with anyone: 123456/build # Generated build artifacts (object files, binaries)CMakelist.txt # Project build definition file/docs # Project docs (README, API docs)/include # Public header files (.hpp)/src # Source files (.cpp) and headers (.hpp)/tests # Test files for unit testing Code Organization with NamespacesAgain, code organization relies quite heavily on the project type and requirements, so its not worth it to delve deep into this, but I think there is a feature that it is worth mentioning called Namespaces. A namespace is a declarative region that provides a unique scope for identifiers like classes, functions, variables… This is quite useful to prevent name conflicts. Let’s see a quick example and also learn why using namespace can be dangerous: 12345678910111213141516#include &lt;list&gt;using namespace std;template &lt;class TClass&gt;class list{ // list members...};int main(){ // So... what list are we trying to initialize? // This won't compile due to name collision list&lt;int&gt; my_list{};} Now you can clearly see why using namespace is discouraged in most cases. Let’s see a counterexample on how to deal with this situation: 12345678910111213#include &lt;list&gt;template &lt;class TClass&gt;class list{ // list members...};int main(){ std::list&lt;int&gt; my_list{}; // Standard library list list&lt;int&gt; my_other_list{}; // custom list} This can be also be seen in the same project: 12345678910111213141516171819202122232425262728293031323334// src/core/Tensor.hppnamespace app::core{ class Tensor { // ... };};// src/models/Tensor.hppnamespace app::models{ class Tensor { // ... };}// src/MainApplication.hpp#include &lt;core/Tensor.hpp&gt;#include &lt;models/Tensor.hpp&gt;namespace app{ class MainApplication { public: // ... private: core::Tensor cTensor_; models::Tensor mTensor_; }} Don’t get me wrong, using namespace can be useful and does indeed improve readability when it is pretty much clear what are we trying to use. Let’s see a use case example: 12345// Constants.hppconstexpr std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_a{yabba::daba::doo::quite::a::mouthfull::MyEnum::First};constexpr std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_b{yabba::daba::doo::quite::a::mouthfull::MyEnum::Second};constexpr std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_c{yabba::daba::doo::quite::a::mouthfull::MyEnum::Third};constexpr std::initializer_list&lt;yabba::daba::doo::quite::a::mouthfull::MyEnum&gt; constant_d{yabba::daba::doo::quite::a::mouthfull::MyEnum::Forth}; As you can see, dealing with nested namespaces can be quite verbose, this verbosity can be necessary but it is indeed a double edged sword. As it is certain that we know what types we are dealing with, this is a perfect situation to use using namespace: 123456// Constants.hppusing namespace yabba::daba::doo::quite;constexpr std::initializer_list&lt;mouthfull::MyEnum&gt; constant_a{mouthfull::MyEnum::First};constexpr std::initializer_list&lt;mouthfull::MyEnum&gt; constant_b{mouthfull::MyEnum::Second};constexpr std::initializer_list&lt;mouthfull::MyEnum&gt; constant_c{mouthfull::MyEnum::Third};constexpr std::initializer_list&lt;mouthfull::MyEnum&gt; constant_d{mouthfull::MyEnum::Fourth};","link":"/cpp-course-basic/1-5-Basic-Project-Structure/"},{"title":"C++Basics 1 Fundamental types and operators","text":"Primitive typesPrimitive types are simple types that represent data in its simplest form, all primitive types are trivially copiable and do not offer any functionality besides storing information in a meaningful way. Primitives represent both meaning (a character, a number…) and a specific size (amount of bits that are needed to store them in memory). Some primitive data types are: IntegerInteger data types represent whole numbers without a fractional or decimal part. They can be signed (positive, negative, or zero) or unsigned (only positive or zero). 123456// 32 bitsint my_int = -42; // Can store negativesunsigned int my_uint= 42;// 64 bitslong my_long = -1024; // Can store negativesunsigned long = 1024; CharacterCharacter data types represent individual characters from a character set, like ASCII or Unicode. In C++, char is commonly used to represent characters. 12char my_char = 'c';char my_char = 42; // Also valid! Chars are 8 bit numbers interpreted as ASCII BooleanBoolean data types represent binary values, typically used for true (1) or false (0) conditions. In C++, bool is used for Boolean data. 12bool my_true_bool = true;bool my_false_bool = false; Floating PointFloating-point data types represent numbers with a fractional part. In C++, float is a single-precision floating-point type. 1float my_float = 42f; Double Floating PointDouble-precision floating-point data types are used to represent numbers with a larger range and higher precision compared to ‘float’. In C++, ‘double’ is commonly used. 1double my_double = 3.141592653589793; Valueless or VoidThe void data type in C++ is used to indicate that a function does not return any value or to declare generic pointers that do not point to a specific data type. 123void myFunction() { // This function does not return a value}void* genericPointer; //We'll get to that in a while... Modern primitive typesMore primitive types are available for improved precision and clarity, most of these are available by including for example &lt;cstdint&gt;, these will import types like uint32_t. These types are usually preferred than the standard primitives as they offer better readability. For example, lets say we want to store an 8 bit value (like a single channel RGB value): 1char my_red_channel_value = 125; The only primitive type that stores an 8 bit value is a char, we are matching its size but its meaning can (and will) be quite confusing for another reader, for this situations we can use uint8_t: 1std::uint8_t my_red_channel_value = 125; Under the hood it will behave the same but we have greatly improved the readability of the code. Variable declaration and use of operatorsVariable declaration in C++ is quite straightforward: 123int my_int, my_other_int;float my_float, my_other_float;bool my_bool; It can also be said with operator usage, C++ offers a rather large collection of operators that can be used by objects, and primitives, this is no different than calling a function, but in a more readable way. 123456789int a = 12, b=30;int result = a + b; // result = 42int my_sum_function(int a, int b){ return a+b;}int other_result = my_sum_function(a,b); // result = 42 Type inference with autoType inference is a feature usually seen in more high-level languages like Python and javascript. Although C++ is a static language that doesn’t mean that we cannot use type inference in some situations to avoid verbose code. Let’s see an example: 12345/// This is a common case when dealing with iteratorsstd::list&lt;MyLovelyObject&gt;::iterator it = my_list.begin();// Most would just prefer...auto it = my_list.begin(); Be aware that type inference in C++ has its limitations, auto needs to receive data at the moment of declaration: 1234// This won't workauto my_type;my_type = 42;","link":"/cpp-course-basic/1.1-Fundamental-types-and-operators/"},{"title":"","text":"","link":"/article/CudaThing/"},{"title":"C++Medium - Type Conversion and Object Casting","text":"Type conversion is a key concept in any strongly typed language. It allows us to convert data of one type to that of another. Whether you’re working with primitives, managing class hierarchies, or interfacing with APIs, type conversions determine how data is interpreted and how objects behave. Type ConversionType conversion occurs whenever a value of one type is transformed into another type. C++ supports two broad categories. Implicit ConversionsThese occur without writing a cast: 12double a {42.42};int b{a}; // a is implicitly converted to double but values can be truncated due to narrowing conversion: b = 42 As you can tell, in the previous example b losses the decimal data from a, safe convertion does not avoid data loss. Implicit conversions aim to be safe, but narrowing conversions (like double → int) may still happen and can silently lose data. Explicit ConversionsAs it names suggest explicit type conversions need the programmer to manually change data from one type to another. This is also known as Type Casting. There are 3 major ways in which we can use explicit conversion in C++: C Notation Function Notation C++ Casts As you will see the older C and C++ notations are discouraged because these notations hide the intent of the conversion and can silently perform dangerous reinterpretations. Prefer C++ casts because they make your intent explicit. C Notation (discouraged)As the name suggests, this type of casting is favored in C . It is also known as cast notation. 123456/// Syntax:/// (data_type)expressionint my_int {12};double my_double{}; // Remember to not rely on default initialization!my_double = (double)my_int; Function Notation (discouraged)We can also use the function-like notation to cast data from one type to another. 1234567/// Syntax:/// data_type(expression)int my_int {12};double my_double{};my_double = double(my_int); C++ CastsThe most idiomatic way of dealing with type casting is by using C++ Casts, C++ offers four expressions for explicit type conversion: static_cast dynamic_cast const_cast reinterpret_cast The key of using C++ casts is to know when and how to use each one. Let’s explore each cast, understand its purpose, and discuss when it should or should not be used. static_castIt is the most common and most versatile C++ cast. static-cast uses a combination of implicit of implicit and user-defined conversions to work properly. In practice this means that this cast is compile-time checked and mostly safe. 12345/// Syntax:/// static_cast&lt;new_type&gt;(expression)double my_double {42.42};int my_int {static_cast&lt;int&gt;(my_double)}; When To Use: For well-defined and compile checked conversions. Numeric conversions. Upcasting in inheritance. Calling explicit constructors. When not to use: When downcasting polymorphic classes -&gt; use dynamic_cast instead. When the conversion may be unsafe or ambiguous. dynamic_castThis cast should exclusively be used on polymorphic types (AKA, classes with at least one virtual method). The most common use case for dynamic_cast is on Downcasting. In practice this means that this cast performs a runtime safety check and prevents unsafe conversions by returning nullptr. 123456789101112131415/// Syntax:/// dynamic_cast&lt;new_type&gt;(expression)Base* base = new Derived{};// Perform Downcast from Base to DerivedDerived* derived = dynamic_cast&lt;Derived*&gt;(base);if (derived){ // Conversion succesful}else{ // Conversion failed} When To Use: When you need to downcast. When dealing with class hierarchies and dynamic polymorphism. When not to use: When dealing with non-polymorphic types. When performance is critical. dynamic_cast can be expensive due to vtable lookups. const_castThis cast expression adds or removes const or volatile qualifiers. Usage of this cast expression is reduced only to compatibility with legacy APIs and a few corner cases. The reason is that removing const from a truly constant object and then modifying it is undefined behavior. 1234567891011121314151617/// Syntax:/// const_cast&lt;type_w/o_const&gt;(expression)void foo(int* value){ ...}int main(){ const int value {42}; // a const int foo(const_cast&lt;int*&gt;(&amp;value)); // dangerous: UB if foo modifies it int x = 42; // a non-const int const int* value = &amp;x; foo(const_cast&lt;int*&gt;(&amp;value)); // safe: x was not originally const} When To Use: When passing const pointers to legacy APIs Removing const from objects that originally were non-const When not to use: Anytime modifying a truly const object. In any other case the use of this cast is strongly discouraged. reinterpret_castThis is most likely the most dangerous type of cast. It reinterprets the raw bits of a value or pointer as another completely unrelated type. Because it can easily break aliasing rules, type safety, and memory assumptions, use it only when you fully understand the implications. It is good practice to be skeptical and cautious when encountering this casting expression on a code base and it should also be accompanied by a comment block justifying the use of this cast and why it is necessary. 123456/// Syntax:/// reinterpret_cast&lt;new_type&gt;(expression)std::uint32_t raw = 0xDEADBEEF;// Comment explaining why reinterpret_cast is necessarychar* bytes = reinterpret_cast&lt;char*&gt;(&amp;raw); When To Use: In low-level programming. When dealing with hardware or network packets. When not to use: Everywhere else. TL;DR Use the right cast Prefer static_cast for normal, well-defined conversions. Use dynamic_cast only when downcasting polymorphic objects and you need runtime safety. Use const_cast only to interface with legacy APIs, never modify a truly const object. Use reinterpret_cast only when absolutely necessary in low-level code, it is dangerous. Avoid C-style and function-style casts because they hide intent and may perform unsafe conversions. Object Casting in C++When dealing with inheritance, C++ allows you to convert pointers and references between base and derived types. These conversions called object casting, are central to polymorphism, but must be used carefully to avoid undefined behavior. UpcastingUpcasting is converting a derived type to its base type: 1234567DerivedA derived{};Base* ptr = &amp;derived; // Upcast — implicit and always safe// Quite useful to make heterogeneous containersstd::list&lt;Base*&gt;list{};list.push_back(ptr);list.push_back(new DerivedB{}); Upcasting works because a Derived object is a Base and it is always safe. Calling virtual functions through Base* or Base&amp; dispatches to overridden Derived implementations. 1234567891011121314151617181920212223242526272829class Base{ public: ... virtual void foo() { std::cout &lt;&lt; &quot;Base foo&quot; &lt;&lt; std::endl; } ...};class Derived: public Base{ public: ... void foo() { std::cout &lt;&lt; &quot;Derived foo&quot; &lt;&lt; std::endl; }};int main(){ Base* ptr = new Derived{}; // static_cast can be used but it can also be implicit Base* ptr_b = static_cast&lt;Base*&gt;(new Derived{}); ptr-&gt;foo(); // Prints Derived Foo ptr_b-&gt;foo(); // Prints Derived Foo} DowncastingDowncasting converts a base type to a derived type. Downcasting is not inherently safe because a Base* may not actually point to a Derived object. When done incorrectly, the behavior is undefined. For safe downcasting, C++ offers dynamic_cast, which relies on runtime type information (RTTI). RTTI has its limitations: Works only with polymorphic types (at least one virtual function). On pointer types: success -&gt; valid pointer failure -&gt; nullptr On reference types: failure -&gt; throws std::bad_cast 123456789101112Base* b = new Derived();Derived* d_scast = static_cast&lt;Derived*&gt;(b); // Downcast, unsafe unless you KNOW the dynamic typeDerived* d = dynamic_cast&lt;Derived*&gt;(b); // Safe downcastif (dynamic_cast&lt;Derived*&gt;(b)){ // Success: b actually pointed to a Derived}else{ // Failed: b was not a Derived} Object SlicingObject slicing occurs when a derived object is assigned or passed by value into a base-type variable: 12Derived d;Base b = d; // Slices off Derived-specific parts The Base object receives only its own fields; all Derived state is lost. 12345678910111213141516171819202122232425262728class Base{ public: ... virtual void foo() { std::cout &lt;&lt; &quot;Base foo&quot; &lt;&lt; std::endl; } ...};class Derived: public Base{ public: ... void foo() { std::cout &lt;&lt; &quot;Derived foo&quot; &lt;&lt; std::endl; }};int main(){ Base* ptr = new Derived{}; // Object is sliced and Derived specific info is lost Base value = *ptr; value.foo(); // Prints Base Foo} To avoid slicing: Pass by reference or pointer Use smart pointers (std::unique_ptr, etc.) Design classes for polymorphic use (virtual destructors, etc.)","link":"/cpp-course-intermediate/2-1-Type-Conversion-And-Casting/"},{"title":"C++Medium - Ownership and Resource Management","text":"In the Basics Course we explored how to manage memory resources by using tools like pointers to allocate, access and modify the memory located in the Heap. Memory located in the heap require manual control of data lifetime thus, requiring careful management to avoid memory leaks or illegal memory accesses. Here is a quick recap on what operators are used on heap memory management: In C we have the following operators: malloc(size) is used to dynamically allocate a block of memory on the heap. memcpy(dest, source, size) is used to copy a block of memory from one location to another. free(ptr) is used to release memory previously allocated on the heap. In C++ we have modern alternatives that usually work better than their C counterparts new is used to dynamically allocate a block of memory on the heap. delete is used to release memory previously allocated on the heap. 123456789int main(){ int* valA_ = new int{42}; MyClass* valB_ = new MyClass{}; /// ... delete valA_; delete valB_; ///...} So far, by simply calling new and delete by themselves, we haven’t fully leveraged the advantages of object-oriented programming. OOP provides a powerful concept called ownership. Introducing OwnershipIn OOP mid-level languages like C++ and Rust, ownership and resource management are central concepts that define who is responsible for an object’s lifetime, when memory or resources are released, and how to avoid memory leaks or undefined behavior. Proper management is critical, because there’s no garbage collector the programmer is responsible for cleaning up. Ownership ModelsOwnership refers to which part of the program is responsible for an object. The most known models are: Exclusive Ownership std::unique_ptr One owner is responsible for the lifetime of the object. Safe: no accidental sharing or double deletes. Shared Ownership std::shared_ptr Multiple owners can hold references to the same object Lifetime is tied to the number of owners; object is destroyed when the last owner is gone. Weak Ownership std::weak_ptr A pointer or reference to an object without taking ownership. Must be careful: the reference must not outlive the object. Ownership in C++: RAIIRAII (Resource Acquisition Is Initialization) is the idiomatic C++ approach to resource management. It’s one of the most powerful features that sets C++ apart from C, because it ties resource lifetime directly to object lifetime, eliminating many manual memory management errors. To archieve RAII-like features and object must (roughly) display the following behaviors: Adquire a resource in a constructor. Release the resource in the destructor. Ensure that resources are always released, even in the presence of exceptions. RAII is more than a coding pattern, it is a defining concept in C++. Until now, classes and structs have often served as mere semantic wrappers. Ownership and RAII give them deeper meaning by binding the lifetime of their members to the lifetime of their owner. This principle not only ensures safe and predictable behavior but also translates directly into UML diagrams, making relationships, ownership, and lifetimes explicit and easy to reason about. Many standard C++ features leverage RAII. For example, STL containers manage their own memory, which is why you do not need to manually delete elements when using containers like std::list or std::vector. RAII is fundamental to writing clear, maintainable, and safe C++ code understanding it is essential for any C++ developer. RAII in actionLet’s see an example on how RAII is implemented in a custom object. 12345678910111213141516171819202122/// Minimal exampleclass MyClass{ public: MyClass(const std::list&lt;int&gt;&amp; list) : list_{list} , my_data_{new float{}} // Constructor acquires the resource { } ~MyClass() { delete my_data_; // The destructor releases the resource } private: // List is a reference, not owned by this instance const std::list&lt;int&gt;&amp; list_; // my_data_ is a pointer initialized in the constructor, so the object is responsible of managing its lifetime float* my_data_; // The object owns the resource (my_data_)}; RAII can be fully achieved by giving objects the necessary behaviors to manage their own memory. However, C++ already provides tools and classes in the STL that implement RAII for us, one of the most used are smart pointers. Smart PointersSmart pointers allow you to manage resources automatically and make it explicit that the object follows RAII principles, often reducing boilerplate and potential errors. In C++, they come in three flavors, corresponding to different ownership models: std::unique_ptrstd::unique_ptr represents exclusive ownership of a resource. Only one unique_ptr can own the object at a time. When the unique_ptr goes out of scope, it automatically deletes the resource. 1234#include &lt;memory&gt;auto ptr = std::make_unique&lt;int&gt;(42); // Creates a unique_ptr managing an int// No need to manually delete it; it will be released automatically Key points: It cannot be copied, only moved. Most performant-wise type of smart pointer. Ideal for single ownership. std::shared_ptrstd::shared_ptr represents shared ownership. Multiple shared_ptr instances can manage the same resource. The resource is only deleted when the last owner goes out of scope. Internally, shared_ptr maintains a reference counter: the counter increases when it is copied and decreases when one of its instances is destroyed. When the counter drops to zero, the resource is automatically deleted. 12345#include &lt;memory&gt;auto ptr1 = std::make_shared&lt;int&gt;(42);auto ptr2 = ptr1; // Both ptr1 and ptr2 share ownership// Resource will be deleted automatically when both go out of scope Key points: Maintains a reference count internally. Use when multiple parts of your app needs access to the same resource (Strong Association). Heavier on performace that unique_ptr due to reference counting. std::weak_ptrstd::weak_ptr is a non-owning reference or weak ownership to a resource managed by a shared_ptr. It allows you to observe the resource without affecting its lifetime, which is useful to avoid cyclic references. 12345678#include &lt;memory&gt;auto shared = std::make_shared&lt;int&gt;(42);std::weak_ptr&lt;int&gt; weak = shared; // weak_ptr does not increase reference countif (auto observed = weak.lock()) { // Safe access to the resource} Key points: Does not manage or control resources lifetime Can be converted to shared_ptr temporarily with lock() -&gt; borrows ownership temporarily Common in observer patterns","link":"/cpp-course-intermediate/2-2-Ownership-And-Resource-Management/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"}],"categories":[{"name":"cpp-course-basic","slug":"cpp-course-basic","link":"/categories/cpp-course-basic/"},{"name":"article","slug":"article","link":"/categories/article/"},{"name":"cpp-course-intermediate","slug":"cpp-course-intermediate","link":"/categories/cpp-course-intermediate/"}],"pages":[{"title":"Home","text":"Hi, I’m VíctorQt/C++ Software Developer About Me | Projects","link":"/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"C++ Course","text":"It’s been a while since I started working with C++, and without a doubt, I’ve learned so much thanks to my amazing co-workers and all those unsung heroes on Stack Overflow who take the time to answer questions. This course is my way of saying thank you for all your time and patience, and, in a very Starship Troopers way, showing that I’m doing my part! In this series, we’ll cover the concepts I’ve found most useful in real-world C++ development, the very techniques and patterns I rely on every day. This course has been tailored to take you from the foundations of C++ (with occasional peeks into C) all the way to advanced and correct practices of modern C++. Without further ado, let’s get started: C++ Basics Course OutlineGoals: Understand memory, types and simple object orientation Be able to write basic C++ programs with structs and classes in a structured way 1. Fundamental Types and Operations Primitive types (int, float, bool, char, etc.) Variable declarations and assignment Good usage of type inference with auto 2. Compound Types and Memory Arrays and structs (Plain Old Data) Introduction to pointers C-like pointers (malloc, free, memcpy) C++ memory management (new, delete) References vs Pointers 3. Functions Function declarations and signatures Function parameters (pass by value, reference) Return types 4. Object-Oriented Programming in C++ Classes vs Structs Visibility specifiers (public, private, protected) Constructors and destructors Member functions Inheritance and base classes Virtual functions and Interfaces (abstract base classes) 5. Basic Project Structure cpp and hpp files Namespaces for code organization 6. Build and Project Tools Make / CMake basics Header-only vs compiled libraries Include paths and linking overview (optional) Docker containers for development C++ Intermediate Level Course OutlineGoals: Write idiomatic C++17 code using smart pointers, lambdas and STL resources Understand how ownership, moves, and references affect performance 1. Type Conversion Implicit Conversion Explicit Conversion C Notation Function Notation C++ Casts static_cast dynamic_cast const_cast reinterpret_cast Object Casting in C++ Upcasting and Downcasting Object slicing 2. Ownership and Resource Management Ownership models C++ idiom: RAII: Resource Acquisition Is Initialization Smart pointers- unique_ptr- shared_ptr- weak_ptr- Comparison with raw pointers- Common gotchas (e.g., circular references with shared_ptr) 3. Move Semantics and Value Categories Value categories std::move Move constructors and move assignment When and why to move Copy elision (brief mention of RVO and NRVO) 4. Lambda Functions Basic syntax and usage Captures: Capture by value/reference Default capture modes ([=], [&amp;]) **Function objects `std::function and high-order functions Mutable lambdas Generic lambdas (auto parameters, C++14+) Lambdas in std::algorithm (e.g. std::sort, std::for_each) 5. Standard Library Containers Sequence containers: std::vector, std::list Range-based for loops Associative containers: std::map, std::unordered_map Utilities: std::tuple Algorithms std::sort, std::find, std::transform, std::for_each Usage with lambdas and iterators Optional values std::optional Wildcard objects: std::variant &amp; std::any 6. Design Patterns Applied to C++ Singleton (yikes) Adapter Façade Factory and Abstract Factory C++ Advanced Level Course OutlineGoals: Archieve correct template usage and good undestanding of metaprogramming and generics Design type-safe, generic and concurrent systems in modern C++ 1. Concurrency and Multithreading std::thread, std::mutex, std::lock_guard std::async, std::future 2. Generic Programming and Template Metaprogramming2.1. Pre-Template Genericity The C Way: void* and manual casting Risks and limitations 2.2. Templates: The Basics Function templates Class templates Template parameters: types, values (int N), template templates Template argument deduction and CTAD (C++17) 2.3. Variadic Templates Variadic template parameters sizeof... Fold expressions (C++17) Recursive unpacking vs fold idioms 2.4. Specialization and Customization Template specialization- Full specialization- Partial specialization Overloading vs specialization Traits idiom: std::type_traits, custom traits 2.5. Compile-Time Logic constexpr vs consteval if constexpr (C++17) Type trait branching with std::conditional 2.6. SFINAE and Substitution Control SFINAE basics std::enable_if, std::void_t Overload selection based on traits Tag dispatching idiom 2.7. Modern Alternatives (Preview of C++20 Features) Concepts (if touching C++20) Basic usage: requires, standard concepts like std::same_as Comparison to SFINAE 3. Advanced Object-Oriented Patterns CRTP: Curiously Recurring Template Pattern Policy-based design Type Erasure (std::function, std::any, std::variant) Strategy pattern, Callbacks and injectable high-order functions","link":"/cpp-course/index.html"},{"title":"Curriculum Vitae","text":"Qt/C++ Software DeveloperOrbital Critical Systems (October 2022 - Now) Software Developer for Airbus Defence &amp; Space on behalf of Orbital Critical Systems. Work on Client. Project: Mission Support Facility (Mission Ground Support for the C295/CA&amp;IR) Mission Support Facility is a ground application that lives within the ecosystem of Mission Control and Inteligence of Airbus, tightly related to its airborne counterpart FITS (Fully Integrated Tactical System) fitted into the C295ISR. The main role of this plane is maritime patrol, surveillance and anti-submarine missions. It is used for review or debrief missions and to create missions with pre-loaded mission elements like important geographical points, known contacts or restricted FIRs within others. Ada/C Junior Software DeveloperIndra Sistemas (September 2020 - September 2022) SACTA (Sistema Automatizado de Control de Trafico Aéreo) is system in charge of managing air trafic. Its mission is to facilitate ATS usages from ENAIRE. Contributed to the development of SACTA, ENAIRE’s Automated Air Traffic Control System, within the Air Traffic Simulation Department for ATM. The application simulates planes and maneuvers defined in performances and protocols to be managed by ATC personnel. Also radar communications and ASTERIX message categories are also simulated, providing a realistic training environment that serves as a sandbox for junior and in-training air traffic controllers. C/AL Junior Software Developerd4bSolutions (March 2020 - June 2020) db4Solutions Navision/Microsoft 365 ERP Internship at db4Solutions. db4Solutions develops and maintains customized Navision/Microsoft 365 tools for pymes and other companies to track stock, sales and accounting.","link":"/curriculum/index.html"}]}