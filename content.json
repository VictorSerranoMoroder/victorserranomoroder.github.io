{"posts":[{"title":"C++Basics 2. Compound Types and Memory","text":"Compound TypesSo far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory. We’ll first explore two foundational building blocks of structured data: Arrays Structs ArraysArrays are one of the simplest memory structures in C and C++. They represent a contiguous block of memory, where elements of the same type are stored sequentially. Depending on how they’re declared, arrays can reside on the stack, in static storage, or be dynamically allocated in the heap. Let’s see an example of its syntax: 12345// Allocates enough memory to store 5 integersint foo[5];// Allocates enough memory to store the following listint bar[] = {1,2,3}; Being contiguous blocks of memory arrays support random access: 12345int foo[] = {1,2,3};foo[2] = 42; // Now foo stores {1,2,42} StructsStructs are a way to group different types of data together into a single compound type. 123456789101112struct Foo{ int a; int b; int c;};//Supports only list-initializationFoo my_struct{1,2,3};//Access to a member variablemy_struct.a = 12; Introduction to Memory ManagementC/C++ are mid-level languages, this means that while they keep some sort of abstraction with the machine it also has tools to be able to interact directly with it. The main way of interacting with the machine is by altering and accessing directly its memory layout, this is done using pointers. Heap and StackHeap and stack are regions of memory used by the application. Stack Memory is used for local variables and function call management.When the function returns, this memory is automatically freed. Key characteristics: Fast allocation and deallocation. Memory size is limited (usually a few MB). Variables only live as long as the function is active. Typical use: local variables, function parameters, return addresses 1int x = 42; // x lives on the stack Heap Memory is used for dynamic allocation, where you control the lifetime of data. Key characteristics: Slower to allocate/deallocate than the stack. Much larger than the stack. Useful for objects whose size or lifetime isn’t known at compile time. Requires careful management to avoid memory leaks. 12int* ptr = new int(42); // allocated on the heapdelete ptr; // manually freed A rule of thumb is to avoid Heap memory allocations when possible, heap memory is slower and more dangerous, but indispensable in many applications. Heap Memory ManagementHeap memory requires manual management in C/C++. In C we have the following operators: malloc(size) is used to dynamically allocate a block of memory on the heap. memcpy(dest, source, size) is used to copy a block of memory from one location to another. free(ptr) is used to release memory previously allocated on the heap. In C++ we have modern alternatives that usually work better than their C counterparts new is used to dynamically allocate a block of memory on the heap. delete is used to release memory previously allocated on the heap. 12345// Creates a new variable that holds the memory address that stores the value 42int* foo = new int{42};// Frees the allocated memorydelete foo; Heap Memory Access (Pointers *)Working with heap memory requires pointers—variables that store memory addresses. Pointers allow you to access and manipulate dynamically allocated memory directly. Let’s see an example of how pointers work: 1234int* foo = new int{42}; int* bar = foo; // modify the value through the pointer*bar = 12; // de-references the value and changes it In the previous example we’ve introduced the concept of de-reference when using *my_ptr we are accessing the stored value, otherwise with my_ptr we would access the memory address directly. de-reference is used to access the pointers pointed memory for both read and write. Pointers can also be initialized as nullptr allowing for dynamic allocation: 1234int* a = nullptr;int b {24};a = new int{&amp;b}; Although, nullptr access will generate a critical error in form of a segmentation fault and exit the application inmediately. Fortunately the following concept offers safer memory access by demanding a valid address on initialization. Heap Memory Access (References &amp;)A reference is an alias for an existing variable. Unlike pointers, references cannot be null and must be initialized when declared. References are often safer and more convenient than pointers, but they cannot be used for dynamic memory allocation themselves. 12int a = 42;int&amp; b = a; Syntax CheatsheetC++ syntax can be confusing when dealing with pointers, here is a brief reminder of how to use it: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt; // for memcpyint main() { // Initialization int a {42}; int* b {nullptr}; // pointer initialized to null int&amp; c {a}; // reference to a // Assign pointer to address of a b = &amp;a; // Access values std::cout &lt;&lt; &quot;Pointer b holds address: &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dereferenced value *b: &quot; &lt;&lt; *b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Reference c: &quot; &lt;&lt; c &lt;&lt; std::endl; // Dynamic memory allocation int* heapInt = new int(100); // allocate on heap std::cout &lt;&lt; &quot;Heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Modify through pointer *heapInt = 200; std::cout &lt;&lt; &quot;Modified heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Free memory delete heapInt; // Arrays on heap int* arr = new int[3]{1, 2, 3}; std::cout &lt;&lt; &quot;Array element arr[1]: &quot; &lt;&lt; arr[1] &lt;&lt; std::endl; // Copy memory (like memcpy) int copy[3]; std::memcpy(copy, arr, 3 * sizeof(int)); std::cout &lt;&lt; &quot;Copied array element copy[1]: &quot; &lt;&lt; copy[1] &lt;&lt; std::endl; // Free array memory delete[] arr; return 0;} Key Points: “*” is used to dereference a pointer. &amp; gives the address of a variable. References (int&amp;) are safer aliases; pointers can be null or reassigned. Use new/delete for dynamic memory, new[]/delete[] for arrays. memcpy can copy raw memory, useful for structs or arrays.","link":"/cpp-course-basic/1-2-Compound-types-and-memory/"},{"title":"C++Basics 4 Object-Oriented Programming in C++","text":"","link":"/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/"},{"title":"C++Basics 3. Functions","text":"FunctionsFunctions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability. Function syntaxis and usageIn C++ functions are composed by: return_type function_name(param_type param_name) This example ilustrates basic use cases of functions: 123456789101112131415161718192021#include &lt;iostream&gt;void foo(){ /// Do things...}int sum2(int a, int b){ return a+b;}int main(){ foo(); // Return values can also be used to initialize variables and update existing ones int a = sum2(22,20); std::cout &lt;&lt; a &lt;&lt; std::endl;} Function parameters passFunction parameters are passed into the function scope essentially in one of two ways: Value void foo(param_type param_name) Reference void foo(param_type&amp; param_name param_type2* param_name2) This is a key concept in C++ both on optimization and design let’s delve deep into the details and differences between both. Pass by valuePassing a value through parameter involves making a copy of the original data to be used only during the function scope. This means that any changes on these objects during the function scope will be lost. 1234567891011void foo(int a){ a = 22;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 42 } Although when dealing with primitives this copy is negligible, with larger objects; allocation of considerable memory in frequently called functions, can slow down run-time execution by a considerable amount. Pass by ReferencePassing a parameter through reference (friendly reminder that references are pointers), involves that only the memory address is passed to the function scope, therefore, any changes made within the function scope will be made to the same object that was being passed by parameter in the first place. In other words, changes within the function scope are persistent. 123456789101112131415161718192021void foo(int&amp; val){ val = 12;}void bar (int* val){ val = 4;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 12 bar(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 4 } Parameter pass by reference, as we are only passing a memory address, is quite cheap and efficient. But involves potential unintended value modifications. It is that why a balance has to be archieved, where we, as developers should aim to optimize for performace while ensuring safe memory and data coherence. Function Pass OptimizationAs seen in previous points, the type of parameter pass if not managed correctly can take a considerable impact in runtime. Therefore it is necessary to know when to use one of another. Copying (Deep copying to be more precise) is expensive, only exception are primitive types where copying a number and copying a memory address are almost identical in cost. 1234567891011121314//Both functions are almost identical in cost // This should be preferedvoid foo(int value){ //...}// Although this is valid it adds unnecessary verbosityvoid bar (int&amp; value){ //...} For any other case and specially objects; these should be always passed by reference unless any other restriction is present. This presents a problem as mentioned earlier of unwanted modification or write access to data. This can be avoided by using the const keyword before the parameter type, const type&amp; will pass by reference while only allowing read access. 1234567891011// Allows read &amp; writevoid foo(std::string&amp; str){ //...}// Only allows readvoid bar(const std::string&amp; str){ //...}","link":"/cpp-course-basic/1-3-Functions/"},{"title":"C++Basics 1 Fundamental types and operators","text":"Primitive typesPrimitive types are simple types that represent data in its simplest form, all primitive types are trivially copiable and do not offer any functionality besides storing information in a meaningful way. Primitives represent both meaning (a character, a number…) and a specific size (amount of bits that are needed to store them in memory). Some primitive data types are: IntegerInteger data types represent whole numbers without a fractional or decimal part. They can be signed (positive, negative, or zero) or unsigned (only positive or zero). 123456// 32 bitsint my_int = -42; // Can store negativesunsigned int my_uint= 42;// 64 bitslong my_long = -1024; // Can store negativesunsigned long = 1024; CharacterCharacter data types represent individual characters from a character set, like ASCII or Unicode. In C++, char is commonly used to represent characters. 12char my_char = 'c';char my_char = 42; // Also valid! Chars are 8 bit numbers interpreted as ASCII BooleanBoolean data types represent binary values, typically used for true (1) or false (0) conditions. In C++, bool is used for Boolean data. 12bool my_true_bool = true;bool my_false_bool = false; Floating PointFloating-point data types represent numbers with a fractional part. In C++, float is a single-precision floating-point type. 1float my_float = 42f; Double Floating PointDouble-precision floating-point data types are used to represent numbers with a larger range and higher precision compared to ‘float’. In C++, ‘double’ is commonly used. 1double my_double = 3.141592653589793; Valueless or VoidThe void data type in C++ is used to indicate that a function does not return any value or to declare generic pointers that do not point to a specific data type. 123void myFunction() { // This function does not return a value}void* genericPointer; //We'll get to that in a while... Modern primitive typesMore primitive types are available for improved precision and clarity, most of these are available by including for example &lt;cstdint&gt;, these will import types like uint32_t. These types are usually preferred than the standard primitives as they offer better readability. For example, lets say we want to store an 8 bit value (like a single channel RGB value): 1char my_red_channel_value = 125; The only primitive type that stores an 8 bit value is a char, we are matching its size but its meaning can (and will) be quite confusing for another reader, for this situations we can use uint8_t: 1std::uint8_t my_red_channel_value = 125; Under the hood it will behave the same but we have greatly improved the readability of the code. Variable declaration and use of operatorsVariable declaration in C++ is quite straightforward: 123int my_int, my_other_int;float my_float, my_other_float;bool my_bool; It can also be said with operator usage, C++ offers a rather large collection of operators that can be used by objects, and primitives, this is no different than calling a function, but in a more readable way. 123456789int a = 12, b=30;int result = a + b; // result = 42int my_sum_function(int a, int b){ return a+b;}int other_result = my_sum_function(a,b); // result = 42 Type inference with autoType inference is a feature usually seen in more high-level languages like Python and javascript. Although C++ is a static language that doesn’t mean that we cannot use type inference in some situations to avoid verbose code. Let’s see an example: 12345/// This is a common case when dealing with iteratorsstd::list&lt;MyLovelyObject&gt;::iterator it = my_list.begin();// Most would just prefer...auto it = my_list.begin(); Be aware that type inference in C++ has its limitations, auto needs to receive data at the moment of declaration: 1234// This won't workauto my_type;my_type = 42;","link":"/cpp-course-basic/1.1-Fundamental-types-and-operators/"},{"title":"CudaThing","text":"","link":"/article/CudaThing/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"}],"categories":[{"name":"cpp-course-basic","slug":"cpp-course-basic","link":"/categories/cpp-course-basic/"},{"name":"article","slug":"article","link":"/categories/article/"}],"pages":[{"title":"Home","text":"Hi, I’m VíctorC++ Software Developer About Me | Projects","link":"/index.html"},{"title":"about","text":"I am Victor","link":"/about/index.html"},{"title":"Curriculum Vitae","text":"CareerOrbital Critical Systems (October 2022 - Now)Qt/C++ Software Developer Indra Sistemas (September 2020 - September 2022)Ada/C Junior Software Developer d4bSolutions (March 2020 - June 2020)C/AL Junior Software Developer","link":"/curriculum/index.html"},{"title":"C++ Course","text":"First Lesson","link":"/cpp-course/index.html"}]}