{"posts":[{"title":"C++Basics 2. Compound Types and Memory","text":"Compound TypesSo far, we’ve dealt mostly with basic data types, but rather sooner than later we’ll need more complex objects and ranges that will offer more advanced behaviours. To model complex information, we need compound types—ways to bundle values together and work with them efficiently in memory. We’ll first explore two foundational building blocks of structured data: Arrays Structs ArraysArrays are one of the simplest memory structures in C and C++. They represent a contiguous block of memory, where elements of the same type are stored sequentially. Depending on how they’re declared, arrays can reside on the stack, in static storage, or be dynamically allocated in the heap. Let’s see an example of its syntax: 12345// Allocates enough memory to store 5 integersint foo[5];// Allocates enough memory to store the following listint bar[] = {1,2,3}; Being contiguous blocks of memory arrays support random access: 12345int foo[] = {1,2,3};foo[2] = 42; // Now foo stores {1,2,42} StructsStructs are a way to group different types of data together into a single compound type. 123456789101112struct Foo{ int a; int b; int c;};//Supports only list-initializationFoo my_struct{1,2,3};//Access to a member variablemy_struct.a = 12; Introduction to Memory ManagementC/C++ are mid-level languages, this means that while they keep some sort of abstraction with the machine it also has tools to be able to interact directly with it. The main way of interacting with the machine is by altering and accessing directly its memory layout, this is done using pointers. Heap and StackHeap and stack are regions of memory used by the application. Stack Memory is used for local variables and function call management.When the function returns, this memory is automatically freed. Key characteristics: Fast allocation and deallocation. Memory size is limited (usually a few MB). Variables only live as long as the function is active. Typical use: local variables, function parameters, return addresses 1int x = 42; // x lives on the stack Heap Memory is used for dynamic allocation, where you control the lifetime of data. Key characteristics: Slower to allocate/deallocate than the stack. Much larger than the stack. Useful for objects whose size or lifetime isn’t known at compile time. Requires careful management to avoid memory leaks. 12int* ptr = new int(42); // allocated on the heapdelete ptr; // manually freed A rule of thumb is to avoid Heap memory allocations when possible, heap memory is slower and more dangerous, but indispensable in many applications. Heap Memory ManagementHeap memory requires manual management in C/C++. In C we have the following operators: malloc(size) is used to dynamically allocate a block of memory on the heap. memcpy(dest, source, size) is used to copy a block of memory from one location to another. free(ptr) is used to release memory previously allocated on the heap. In C++ we have modern alternatives that usually work better than their C counterparts new is used to dynamically allocate a block of memory on the heap. delete is used to release memory previously allocated on the heap. 12345// Creates a new variable that holds the memory address that stores the value 42int* foo = new int{42};// Frees the allocated memorydelete foo; Heap Memory Access (Pointers *)Working with heap memory requires pointers—variables that store memory addresses. Pointers allow you to access and manipulate dynamically allocated memory directly. Let’s see an example of how pointers work: 1234int* foo = new int{42}; int* bar = foo; // modify the value through the pointer*bar = 12; // de-references the value and changes it In the previous example we’ve introduced the concept of de-reference when using *my_ptr we are accessing the stored value, otherwise with my_ptr we would access the memory address directly. de-reference is used to access the pointers pointed memory for both read and write. Pointers can also be initialized as nullptr allowing for dynamic allocation: 1234int* a = nullptr;int b {24};a = new int{&amp;b}; Although, nullptr access will generate a critical error in form of a segmentation fault and exit the application inmediately. Fortunately the following concept offers safer memory access by demanding a valid address on initialization. Heap Memory Access (References &amp;)A reference is an alias for an existing variable. Unlike pointers, references cannot be null and must be initialized when declared. References are often safer and more convenient than pointers, but they cannot be used for dynamic memory allocation themselves. 12int a = 42;int&amp; b = a; Syntax CheatsheetC++ syntax can be confusing when dealing with pointers, here is a brief reminder of how to use it: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt; // for memcpyint main() { // Initialization int a {42}; int* b {nullptr}; // pointer initialized to null int&amp; c {a}; // reference to a // Assign pointer to address of a b = &amp;a; // Access values std::cout &lt;&lt; &quot;Pointer b holds address: &quot; &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dereferenced value *b: &quot; &lt;&lt; *b &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Reference c: &quot; &lt;&lt; c &lt;&lt; std::endl; // Dynamic memory allocation int* heapInt = new int(100); // allocate on heap std::cout &lt;&lt; &quot;Heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Modify through pointer *heapInt = 200; std::cout &lt;&lt; &quot;Modified heap value: &quot; &lt;&lt; *heapInt &lt;&lt; std::endl; // Free memory delete heapInt; // Arrays on heap int* arr = new int[3]{1, 2, 3}; std::cout &lt;&lt; &quot;Array element arr[1]: &quot; &lt;&lt; arr[1] &lt;&lt; std::endl; // Copy memory (like memcpy) int copy[3]; std::memcpy(copy, arr, 3 * sizeof(int)); std::cout &lt;&lt; &quot;Copied array element copy[1]: &quot; &lt;&lt; copy[1] &lt;&lt; std::endl; // Free array memory delete[] arr; return 0;} Key Points: “*” is used to dereference a pointer. &amp; gives the address of a variable. References (int&amp;) are safer aliases; pointers can be null or reassigned. Use new/delete for dynamic memory, new[]/delete[] for arrays. memcpy can copy raw memory, useful for structs or arrays.","link":"/cpp-course-basic/1-2-Compound-types-and-memory/"},{"title":"C++Basics 3. Functions","text":"FunctionsFunctions are a cornerstone of OOP languages. In a nutshell, functions are fragments of code that can be reused multiple times. This avoids repeated code lines and improves code readability. Function syntaxis and usageIn C++ functions are composed by: return_type function_name(param_type param_name) This example ilustrates basic use cases of functions: 123456789101112131415161718192021#include &lt;iostream&gt;void foo(){ /// Do things...}int sum2(int a, int b){ return a+b;}int main(){ foo(); // Return values can also be used to initialize variables and update existing ones int a = sum2(22,20); std::cout &lt;&lt; a &lt;&lt; std::endl;} Function parameters passFunction parameters are passed into the function scope essentially in one of two ways: Value void foo(param_type param_name) Reference void foo(param_type&amp; param_name param_type2* param_name2) This is a key concept in C++ both on optimization and design let’s delve deep into the details and differences between both. Pass by valuePassing a value through parameter involves making a copy of the original data to be used only during the function scope. This means that any changes on these objects during the function scope will be lost. 1234567891011void foo(int a){ a = 22;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 42 } Although when dealing with primitives this copy is negligible, with larger objects; allocation of considerable memory in frequently called functions, can slow down run-time execution by a considerable amount. Pass by ReferencePassing a parameter through reference (friendly reminder that references are pointers), involves that only the memory address is passed to the function scope, therefore, any changes made within the function scope will be made to the same object that was being passed by parameter in the first place. In other words, changes within the function scope are persistent. 123456789101112131415161718192021void foo(int&amp; val){ val = 12;}void bar (int* val){ val = 4;}int main(){ int value{42}; foo(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 12 bar(value); std::cout &lt;&lt; value &lt;&lt; std::endl; //Prints 4 } Parameter pass by reference, as we are only passing a memory address, is quite cheap and efficient. But involves potential unintended value modifications. It is that why a balance has to be archieved, where we, as developers should aim to optimize for performace while ensuring safe memory and data coherence. Function Pass OptimizationAs seen in previous points, the type of parameter pass if not managed correctly can take a considerable impact in runtime. Therefore it is necessary to know when to use one of another. Copying (Deep copying to be more precise) is expensive, only exception are primitive types where copying a number and copying a memory address are almost identical in cost. 1234567891011121314//Both functions are almost identical in cost // This should be preferedvoid foo(int value){ //...}// Although this is valid it adds unnecessary verbosityvoid bar (int&amp; value){ //...} For any other case and specially objects; these should be always passed by reference unless any other restriction is present. This presents a problem as mentioned earlier of unwanted modification or write access to data. This can be avoided by using the const keyword before the parameter type, const type&amp; will pass by reference while only allowing read access. 1234567891011// Allows read &amp; writevoid foo(std::string&amp; str){ //...}// Only allows readvoid bar(const std::string&amp; str){ //...}","link":"/cpp-course-basic/1-3-Functions/"},{"title":"C++Basics 4. Object-Oriented Programming in C++","text":"Well, I think we’ve found where the ++ in C++ was.I could agree with this statement, at least in its origins, C++ has evolved to be a superset of C that quite revamps it introducing modern concepts. But first things first. The building blocks of OOP, Objects and ResponsibilityC++ is by design an Object-Oriented Programming (OOP) language. OOP is a way of writing programs that organizes data and behavior into objects. An object groups together information (called attributes or member variables) and the actions that can be performed on it (called methods or member functions). This approach makes programs easier to structure, reuse, and maintain. A key principle in OOP design is encapsulation, which means that an object should hide its internal details and only expose what is necessary. Encapsulation helps reduce coupling, making objects more independent and easier to maintain. This prevents objects from reaching deeply into other objects’ internals, further reducing coupling and keeping the design clean. In C++, visibility specifiers are the main tool for enforcing encapsulation: public: members specified as public can be accessed from other objects freely. protected: members specified as protected can be accessed from derived objects. private: members specified as private cannot be accessed from other objects. After a brief dive into the dephts of applied design principles in C++, let’s see how C++ allows us to implement objects, let’s start with an previously visited concept. StructsWe’ve already explored the minimal expression of these objects when we talked about structs.These can behave as: Plain Old Data (POD) objects, in a nutshell, aggregates of data that share a semantic relationship. Objects structures that define not only semantically related data but also behavior in the form of member functions. Struct members have public visibility access by default. 12345678910111213141516171819struct MyAggregate{ // Both a,b are publicly accessible int a; int b; private: int c;};struct MyObject{ int a; int b; void foo() { // ... }}; ClassesClasses are pretty much identical to structs, but feature private default access to members. This is mainly the reason why in practice, classes are preferred over structs as they are seen as better suited for encapsulation. Lets see an example that showcases how classes work: 1234567891011121314151617181920212223242526272829303132class MyClass{ public: // Constructor MyClass(int data) : data_{data} { } int get_data() { foo(); // foo can be called as it is in the same class return data_; } private: void foo() { // ... } int data_;};int main(){ // Initialize object MyClass my_obj{42}; // Call to public function int result = my_obj.get_data(); // Returns 42} In these example we’ve “smoothly” introduced a concept that deserves its own section. Object ConstructorsConstructors are functions that define how an object has to be initialized. Although we are introducing this concept with classes they can be found in structs aswell. A constructor job is to initialize its members. In C++ constructors is good practice to initialize members by List initialization instead of relying on Default Initialization. (We’ll delve more deeply into initialization types in the following course). 123456789101112131415class MyClass{ public: MyClass(int data) : data_{data} //List initialized member { // Other has been default-initialized and then // we have assigned its value. Not optimal. other_ = data; } private: int data_; int other_;} Object DestructorsHaving explained constructors, its easier to understand destructors. Destructors are functions triggered when and object is deleted, depending on where the object is allocated in memory its destruction will be triggered by different reasons: stack: stack allocated objects are deleted when leaving its scope or when its owner deletes it. heap: heap allocated objects are deleted explicitly by a delete call. An important concept is destruction order, when an object is notified to be destroyed it must also notify the destruction of its members, and it does it in a very specific order. In C++ member destruction is triggered in an inverse initialization order or from the bottom to the top. This is important as in some cases it could derive in lifetime issues and it could hinder propper app exit among other subtle possible issues. After all members have been destroyed the object deletes itself. This is also a quick look at how RAII (Resource Adquisition Is Initialization) idiom (pattern) that we will explore in the following course together with the previously mentioned concepts. Let’s get back on track. 1234567891011121314151617181920212223class MyClass{ public: // Constructor initializes both members MyClass(int data) // Latest to destroy : stack_data_{data} , heap_data_{new int{data}} , object_a_{} // Latest to initialize, first to destroy { } // Class destructor ~MyClass() { // Heap allocated memory has to be explicitly deleted delete heap_data_; } private: int stack_data_; int* heap_data_; ObjectA object_a_;}; Inheritance in C++Inheritance is a cornerstone of OOP, the concept is quite simple, a Base class contains members that are semantically common to N Derived classes. This mantains a semantic coherence while also avoiding repeated code and keeping the behavior definition on a single place easying code mantainance. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Base{ public: // Constructor Base(int data) : foo_{data} { } void base_public() { //... } protected: void protected_method() { //... } int kappa_; private: int foo_; //As it is private it cannot be accessed from Derived};class Derived : public Base{ public: Derived(int data) : Base{data} // First needs to initialize Base , bar_{22} { } void derived_public() { // Can access protected members from Base protected_method(); kappa_ = bar_; } private: int bar_;};int main(){ // Initialize object Derived my_obj{42}; my_obj.base_public(); my_obj.derived_public();} The previous example makes use of inheritance only for code reuse, but inheritance can be much more powerful than that. Static &amp; Dynamic PolimorphismWe’re going to introduce 2 new concepts of OOP, static polimorphism and dynamic polimorphism . In C++, Polimorphism can be applied to: functions and operators. Both can be resolved in 1 of 2 ways: In compile-time(Static Polimorphism): function/operator calls are resolved by the compiler, its also present in templates (C++ generics) and forced with CRTP (Curiously Recursive Template Pattern) both will be explored in a later course. In runtime(Dynamic Polimorphism): function calls are resolved in runtime Let’s take a closer look on each type of polymorphism and explain how and when to use them. Static Polimorphism: Function and Operator OverloadIn this post we will explore 2 ways of applying Static Polimorphism, these are Function Overloads and Operator Overloads. Function Overloading is a feature in OOP where 2 or more functions have the same name but different behave differently for different parameters. These functions are said to be overloaded. 1234567891011class MyClass{ public: MyClass() = default; private: // Overloaded functions void foo(); void foo(int a); void foo(float b);}; Static Polimorphism is also archieved by operator overloading. In a nutshell in C++ we can provide the operators(+,-,&lt;&lt;,&gt;&gt;…) specific meaning. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;class MyClass{ public: MyClass(int data) : data_{data} { } // Overloaded == operator bool operator==(const MyClass&amp; right) { // First check if we're comparing it with itself // this is usually a good practice with operators if (this == &amp;right) return true; return data_ == right.data_; } private: int data_;};int main(){ // Initialize object MyClass foo{42}, bar{22}; if (foo == bar) { std::cout &lt;&lt; &quot;equal&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;not equal&quot; &lt;&lt; std::endl; }} Dynamic Polimorphism: Virtual methodsDynamic Polimorphism, also known as late binding in contrast to static polymorphism it is resolved at runtime. This has many benefits as we could change the behavior of a method from a Base depending on specializations of each Derived object. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Base{ public: // Constructor Base(int data) : foo_{data} { } void base_public() { // Function can be called from the Base but execute Derived specific // implementations my_fun(); my_pure_fun(); } virtual void my_fun() { std::cout &lt;&lt; &quot;Base myfun implementation&quot; &lt;&lt; std::endl; } protected: // This is called a Virtual method, it has a &quot;default&quot; implementation // than can be overriden in its specializations // This is called a Pure Virtual method, any Derived object MUST // implement a specialization virtual void my_pure_fun() = 0; int kappa_; private: int foo_;};class Derived : public Base{ public: Derived(int data) : Base{data} // First needs to initialize Base , bar_{22} { } void derived_public() { // Can access protected members from Base kappa_ = bar_; } virtual void my_fun() override { std::cout &lt;&lt; &quot;Overriding my_fun&quot; &lt;&lt; std::endl; } // Derived specific implementation of pure virtual functions virtual void my_pure_fun() override { std::cout &lt;&lt; &quot;Pure method overriden&quot; &lt;&lt; std::endl; } private: int bar_;};int main(){ Base obj{42}; // Polymorphic behavior obj.base_public(); // Calls Base but dispatches to Derived implementations obj.my_fun(); // Calls Derives as it is overriding it}","link":"/cpp-course-basic/1-4-Object-Oriented-Programming-in-C/"},{"title":"C++Basics 1 Fundamental types and operators","text":"Primitive typesPrimitive types are simple types that represent data in its simplest form, all primitive types are trivially copiable and do not offer any functionality besides storing information in a meaningful way. Primitives represent both meaning (a character, a number…) and a specific size (amount of bits that are needed to store them in memory). Some primitive data types are: IntegerInteger data types represent whole numbers without a fractional or decimal part. They can be signed (positive, negative, or zero) or unsigned (only positive or zero). 123456// 32 bitsint my_int = -42; // Can store negativesunsigned int my_uint= 42;// 64 bitslong my_long = -1024; // Can store negativesunsigned long = 1024; CharacterCharacter data types represent individual characters from a character set, like ASCII or Unicode. In C++, char is commonly used to represent characters. 12char my_char = 'c';char my_char = 42; // Also valid! Chars are 8 bit numbers interpreted as ASCII BooleanBoolean data types represent binary values, typically used for true (1) or false (0) conditions. In C++, bool is used for Boolean data. 12bool my_true_bool = true;bool my_false_bool = false; Floating PointFloating-point data types represent numbers with a fractional part. In C++, float is a single-precision floating-point type. 1float my_float = 42f; Double Floating PointDouble-precision floating-point data types are used to represent numbers with a larger range and higher precision compared to ‘float’. In C++, ‘double’ is commonly used. 1double my_double = 3.141592653589793; Valueless or VoidThe void data type in C++ is used to indicate that a function does not return any value or to declare generic pointers that do not point to a specific data type. 123void myFunction() { // This function does not return a value}void* genericPointer; //We'll get to that in a while... Modern primitive typesMore primitive types are available for improved precision and clarity, most of these are available by including for example &lt;cstdint&gt;, these will import types like uint32_t. These types are usually preferred than the standard primitives as they offer better readability. For example, lets say we want to store an 8 bit value (like a single channel RGB value): 1char my_red_channel_value = 125; The only primitive type that stores an 8 bit value is a char, we are matching its size but its meaning can (and will) be quite confusing for another reader, for this situations we can use uint8_t: 1std::uint8_t my_red_channel_value = 125; Under the hood it will behave the same but we have greatly improved the readability of the code. Variable declaration and use of operatorsVariable declaration in C++ is quite straightforward: 123int my_int, my_other_int;float my_float, my_other_float;bool my_bool; It can also be said with operator usage, C++ offers a rather large collection of operators that can be used by objects, and primitives, this is no different than calling a function, but in a more readable way. 123456789int a = 12, b=30;int result = a + b; // result = 42int my_sum_function(int a, int b){ return a+b;}int other_result = my_sum_function(a,b); // result = 42 Type inference with autoType inference is a feature usually seen in more high-level languages like Python and javascript. Although C++ is a static language that doesn’t mean that we cannot use type inference in some situations to avoid verbose code. Let’s see an example: 12345/// This is a common case when dealing with iteratorsstd::list&lt;MyLovelyObject&gt;::iterator it = my_list.begin();// Most would just prefer...auto it = my_list.begin(); Be aware that type inference in C++ has its limitations, auto needs to receive data at the moment of declaration: 1234// This won't workauto my_type;my_type = 42;","link":"/cpp-course-basic/1.1-Fundamental-types-and-operators/"},{"title":"CudaThing","text":"","link":"/article/CudaThing/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CUDA","slug":"CUDA","link":"/tags/CUDA/"}],"categories":[{"name":"cpp-course-basic","slug":"cpp-course-basic","link":"/categories/cpp-course-basic/"},{"name":"article","slug":"article","link":"/categories/article/"}],"pages":[{"title":"Home","text":"Hi, I’m VíctorC++ Software Developer About Me | Projects","link":"/index.html"},{"title":"about","text":"I am Victor","link":"/about/index.html"},{"title":"Curriculum Vitae","text":"CareerOrbital Critical Systems (October 2022 - Now)Qt/C++ Software Developer Indra Sistemas (September 2020 - September 2022)Ada/C Junior Software Developer d4bSolutions (March 2020 - June 2020)C/AL Junior Software Developer","link":"/curriculum/index.html"},{"title":"C++ Course","text":"First Lesson","link":"/cpp-course/index.html"}]}